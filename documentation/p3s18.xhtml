<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>com.io7m.jcanephora 0.61.0 Documentation: 3.18. JCGLTimersType</title><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-layout.css"/><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st200_body"><div class="brand">
  <div class="brand_left">
    <a href="http://io7m.com/">io7m</a>
  </div>
  <div class="brand_right">
    <a href="http://github.com/io7m/jcanephora">com.io7m.jcanephora</a> 0.61.0
  </div>
</div><div class="st200_navbar st200_navbar_top"><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_title_cell">3.17. JCGLTexturesType</td><td class="st200_navbar_up_title_cell">3. jcanephora Core Interfaces</td><td class="st200_navbar_next_title_cell">3.19. JCGLViewportsType</td></tr><tr><td class="st200_navbar_prev_file_cell"><a href="p3s17.xhtml#st200_p3s17">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p3.xhtml#st200_p3">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p3s19.xhtml#st200_p3s19">Next</a></td></tr></table><hr class="st200_hr"/></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p3s18" href="#st200_p3s18">3.18</a></div><div class="st200_section_title">JCGLTimersType</div><ul class="st200_contents st200_section_contents_outer st200_section_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="p3s18.xhtml#st200_p3s18ss1">3.18.1. Description</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="p3s18.xhtml#st200_p3s18ss2">3.18.2. Usage examples</a></li></ul><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s18ss1" href="#st200_p3s18ss1">3.18.1</a></div><div class="st200_subsection_title">Description</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s18ss1pg1" href="#st200_p3s18ss1pg1">1</a></div><div class="st200_paragraph">
      The
      <a class="st200_link_external" href="apidocs/com/io7m/jcanephora/core/api/JCGLTimersType.html">
        JCGLTimersType
      </a>
      interface provides functions for allocating and evaluating
      timer queries.
    </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s18ss2" href="#st200_p3s18ss2">3.18.2</a></div><div class="st200_subsection_title">Usage examples</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s18ss2pg1" href="#st200_p3s18ss2pg1">1</a></div><div class="st200_paragraph">
      The <span class="st200_term type">JCGLTimersType</span>
      interfaces expose functions that allocate and evaluate timer
      queries. A timer query is, at the most basic level, a way of
      having the GPU record the current time in a manner that can be
      retrieved by the CPU later on.
    </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s18ss2pg2" href="#st200_p3s18ss2pg2">2</a></div><div class="st200_paragraph">
      To allocate a new timer query:
    </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s18ss2fo1" href="#st200_p3s18ss2fo1">3.18.2.1. Allocation</a></div><pre class="st200_verbatim">
JCGLTimersType g;
JCGLTimerType t = g.timerQueryAllocate();
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s18ss2pg3" href="#st200_p3s18ss2pg3">3</a></div><div class="st200_paragraph">
      A timer query must be asynchronously started and stopped, and
      can then later be queried. For example, to measure the time it
      takes to execute a series of OpenGL commands:
    </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s18ss2fo2" href="#st200_p3s18ss2fo2">3.18.2.2. Timing</a></div><pre class="st200_verbatim">
JCGLDrawType gd;
JCGLTimersType g;
JCGLTimerType t;

g.timerQueryBegin(t);
gd.drawElements(JCGLPrimitives.PRIMITIVE_TRIANGLES);
gd.drawElements(JCGLPrimitives.PRIMITIVE_TRIANGLES);
gd.drawElements(JCGLPrimitives.PRIMITIVE_TRIANGLES);
g.timerQueryFinish(t);
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s18ss2pg4" href="#st200_p3s18ss2pg4">4</a></div><div class="st200_paragraph">
      The <span class="st200_term type">timerQueryBegin/timerQueryFinish</span> commands execute
      asynchronously, recording the current time on the GPU as the GPU
      reaches each command in the queue. The application can then ask the
      GPU if the timer commands have finished executing, and return the
      recorded time values if they have:
    </div></div><div class="st200_formal_item"><div class="st200_formal_item_title"><a id="st200_p3s18ss2fo3" href="#st200_p3s18ss2fo3">3.18.2.3. Retrieval</a></div><pre class="st200_verbatim">
JCGLDrawType gd;
JCGLTimersType g;
JCGLTimerType t;

if (g.timerQueryResultIsReady(t)) {
  long elapsed = g.timerQueryResultGet(t);
  // The time to execute the three draw commands is time_end - time_start nanoseconds
}
</pre></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s18ss2pg5" href="#st200_p3s18ss2pg5">5</a></div><div class="st200_paragraph">
      At most one timer query can be executing at any one time; calls to
      <span class="st200_term type">timerQueryBegin/timerQueryFinish</span> cannot
      be nested.
    </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s18ss2pg6" href="#st200_p3s18ss2pg6">6</a></div><div class="st200_paragraph">
      Calling <span class="st200_term type">timerQueryResultGet</span> implies
      synchronization between the CPU and GPU and should therefore be called
      after all other rendering operations for the frame have completed. As
      timer queries are most often used to implement OpenGL profiling, this
      is not usually an onerous restriction. Generally, applications will
      allocate many timers for their rendering pipelines, update timers during
      rendering of a frame, and then query all timers at the end of the frame
      to measure the time taken by each part of the pipeline.
    </div></div></div></div><div class="st200_navbar st200_navbar_bottom"><hr class="st200_hr"/><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_file_cell"><a href="p3s17.xhtml#st200_p3s17">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p3.xhtml#st200_p3">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p3s19.xhtml#st200_p3s19">Next</a></td></tr><tr><td class="st200_navbar_prev_title_cell">3.17. JCGLTexturesType</td><td class="st200_navbar_up_title_cell">3. jcanephora Core Interfaces</td><td class="st200_navbar_next_title_cell">3.19. JCGLViewportsType</td></tr></table></div></div></body></html>
