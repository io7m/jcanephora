<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright © 2012 http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://www.io7m.com/schemas/structural/1.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>io7m-jcanephora 1.0.0 Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />
    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term>
          package implements a set of abstractions over
          <s:link-external target="http://opengl.org">OpenGL</s:link-external>
          with the intention of providing an API that enforces program
          correctness statically. The OpenGL API is extremely error prone, but
          thankfully most of the problems can be alleviated with the simple
          application of static types. Where the Java type system is too weak
          to give static guarantees, dynamic checks are used to prevent silent
          failure.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Correctness</s:subsection-title>
        <s:paragraph>
          Most functions in OpenGL return integers (type <s:term type="type">int</s:term>).
          The <s:term type="function">glCreateShader()</s:term> function, for example,
          returns an <s:term type="type">int</s:term> regardless of whether the function
          is creating a fragment shader or a vertex shader. Obviously, returning a different
          type depending on whether a fragment shader or a vertex shader was requested
          would require a dependent type system. As Java clearly does not have dependent types, the
          <s:term type="package">jcanephora</s:term> package
          provides a <s:term type="function">compileVertexShader()</s:term> function that
          returns a value of type <s:term type="type">VertexShader</s:term> and a
          <s:term type="function">compileFragmentShader()</s:term> function that returns
          a value of type <s:term type="type">FragmentShader</s:term>, eliminating any
          chance of confusing the two at compile-time. The package takes a similar
          approach to static safety throughout.
        </s:paragraph>
        <s:paragraph>
          All implementations of the <s:term type="package">jcanephora</s:term> API are
          run through a large battery of tests to ensure consistent semantics.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Convenience</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package also provides
          on-demand (re)compilation of GLSL shader programs via a simple
          <s:term type="type">Program</s:term> API. The package is able to load
          programs from inside archives via
          <s:link-external target="http://io7m.com/software/jvvfs">jvvfs</s:link-external>.
          The <s:term type="type">Program</s:term> API also implements a simple abstraction
          over shading program parameters (attributes, uniforms) that makes it possible
          to query the names and types of parameters at run-time.
        </s:paragraph>
        <s:paragraph>
          The package also provides functions to produce orthographic and perspective
          projection matrices, and an implementation of the ubiquitous
          <s:term type="function">lookAt()</s:term>
          function for producing a view matrix that looks at a given point in space from
          a given location.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Simplicity</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package attempts to
          provide abstractions that are as minimal as possible. It should be
          possible for any experienced OpenGL programmer to use the package
          without having to learn new concepts or fight a complicated class
          hierarchy. The idea is to provide static type safety in as simple
          a manner as possible.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Portability</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package has backends
          for both <s:link-external target="http://www.jogamp.org">JOGL</s:link-external>
          and <s:link-external target="http://www.lwjgl.org">LWJGL</s:link-external>
          and presents a common API, with consistent semantics, for both. At the
          time of writing, the most widely supported version of OpenGL is 2.1. The
          version that followed, 3.0, was the first version to actually deprecate/remove
          obsolete features such as the fixed-function pipeline. The
          <s:term type="package">jcanephora</s:term> API and implementation therefore
          only uses those features of 3.0 that are also present in 2.1, and does not
          use any deprecated and/or obsolete features. This allows programs using
          <s:term type="package">jcanephora</s:term> to run unmodified on just about
          any desktop/workstation graphics hardware produced in the last ten years or
          so.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Source compilation</s:subsection-title>
        <s:paragraph>
          The project can be compiled and installed with
          <s:link-external target="http://maven.apache.org">Maven</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[$ mvn -C clean install]]></s:verbatim>
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Maven</s:subsection-title>
        <s:paragraph>
          Regular releases are made to the
          <s:link-external target="http://search.maven.org/#search|ga|1|jcanephora">Central Repository</s:link-external>,
          so it's possible to use the <s:term type="package">jcanephora</s:term>
          package in your projects with the following Maven dependency:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jcanephora.core</groupId>
  <artifactId>io7m-jcanephora-core</artifactId>
  <version>1.0.0</version>
</dependency>
<dependency>
  <groupId>com.io7m.jcanephora.jogl</groupId>
  <artifactId>io7m-jcanephora-jogl</artifactId>
  <version>1.0.0</version>
</dependency>
<dependency>
  <groupId>com.io7m.jcanephora.lwjgl</groupId>
  <artifactId>io7m-jcanephora-lwjgl</artifactId>
  <version>1.0.0</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
        <s:paragraph>
          Note that it is possible to omit either (but not both) of the
          <s:term type="package">jogl</s:term> or
          <s:term type="package">lwjgl</s:term> packages if your project
          does not need support for both
          <s:link-external target="http://jogamp.org">JOGL</s:link-external>
          and
          <s:link-external target="http://lwjgl.org">LWJGL</s:link-external>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Supported Systems</s:section-title>
      <s:paragraph>
        This release of the software passed 100% of the included unit tests on
        the following platforms:
      </s:paragraph>
      <s:formal-item kind="platform_table" type="platforms">
        <s:formal-item-title>Supported systems</s:formal-item-title>
        <s:table>
          <s:table-summary>Supported systems</s:table-summary>
          <s:table-head>
            <s:table-column-name>OS</s:table-column-name>
            <s:table-column-name>OS-Version</s:table-column-name>
            <s:table-column-name>OS-Arch</s:table-column-name>
            <s:table-column-name>JRE-Vendor</s:table-column-name>
            <s:table-column-name>JRE-Version</s:table-column-name>
            <s:table-column-name>JVM</s:table-column-name>
            <s:table-column-name>JVM-Vendor</s:table-column-name>
            <s:table-column-name>JVM-Version</s:table-column-name>
            <s:table-column-name>GL-Vendor</s:table-column-name>
            <s:table-column-name>GL-Renderer</s:table-column-name>
            <s:table-column-name>GL-Version</s:table-column-name>
          </s:table-head>
          <s:table-body>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.4.4-2-ARCH</s:table-cell>
  <s:table-cell>amd64</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_24</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>20.0-b12</s:table-cell>
  <s:table-cell>Tungsten Graphics, Inc</s:table-cell>
  <s:table-cell>Mesa DRI Intel(R) Sandybridge Mobile </s:table-cell>
  <s:table-cell>3.0 Mesa 8.0.3</s:table-cell>
</s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:subsection>
        <s:subsection-title>X11 (Xorg)</s:subsection-title>
        <s:paragraph>
          When compiling the package from source, the included unit
          tests occasionally (rarely) trigger a bug in
          <s:term type="package">Xorg</s:term>. The bug manifests as
          a "Maximum number of clients reached" message, which usually
          causes one or more of the test cases to fail. The problem seems
          to be related to the number of tests: The maximum number of clients
          allowed to connect to the X server is 256, and at the time of
          writing, there are ~250 unit tests per package.
        </s:paragraph>
        <s:paragraph>
          Unfortunately, the problem seems to be extremely dependent on the
          state of the host system at the time of compilation. As can be seen
          from the test code, the tests take care to destroy any existing
          display context before creating a new one (so even if a test fails,
          the display context it opened is still destroyed correctly upon
          execution of the next test). The display handling code in the tests
          also instructs the JVM to collect garbage after every test, which
          seems to reduce the likelihood of the problem occuring.
        </s:paragraph>
        <s:paragraph>
          There are no known workarounds to the problem. There is also no
          way to raise the limit on the number of clients without changing
          the X11 protocol.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term type="package">jcanephora</s:term>
        package are placed under the following license:
        <s:verbatim type="license"><![CDATA[Copyright © 2012 http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>jcanephora For OpenGL Programmers</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        As stated repeatedly, the <s:term type="package">jcanephora</s:term>
        package strives for increased static and run-time type safety. This
        does, however, mean that there are new abstractions to learn. This
        section of the documentation attempts to describe how to use the API
        for those already familiar with OpenGL. It presents small programs
        written in C and then shows the <s:term type="package">jcanephora</s:term>
        equivalent.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Vertex Buffer Objects</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="vbo.c">vbo.c</s:link-external>]
        demonstrates the creation of vertex buffer and index buffer objects
        in plain OpenGL. It creates buffers and then draws them to the screen
        using the fixed-function OpenGL pipeline.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffers (C)</s:formal-item-title>
        <s:verbatim><xi:include href="../c/vbo.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Where the <s:link-external target="vbo.c">C version</s:link-external>
        creates essentially untyped memory, the <s:term type="package">jcanephora</s:term>
        version requires programmers to use explicit type descriptors for
        buffers. In order to write to the map, the programmer has to obtain
        access via typed cursors. Intuitively, if the array buffer is thought
        of as an array of records of a given type, the cursors can only point
        to specific fields in the records as they seek through the array. Note
        that in order to avoid introducing too much of the API at once and
        for direct comparison with the C version, the
        example code drops down to the fixed-function pipeline (via LWJGL)
        for rendering.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffers (Java)</s:formal-item-title>
        <s:verbatim><xi:include href="../../../io7m-jcanephora-lwjgl/src/main/java/com/io7m/jcanephora/examples/lwjgl30/VBOExample.java" parse="text"/></s:verbatim>
      </s:formal-item>
    </s:section>
    <s:section>
      <s:section-title>Textures</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="texture-use.c">texture-use.c</s:link-external>]
        demonstrates the creation and usage of textures. It loads a TIFF
        image using <s:link-external target="http://libtiff.org">libTIFF</s:link-external>,
        into a pixel buffer, copies the pixel buffer into a texture,
        binds the texture to the first texture unit, and displays it on a
        textured quad.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (C)</s:formal-item-title>
        <s:verbatim><xi:include href="../c/texture-use.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> version reads an RGBA
        texture directly from a file. The image is converted to RGBA regardless
        of the format of the image. The <s:term type="package">jcanephora</s:term>
        package requires the programmer to retrieve a list of the available
        texture units and then explicitly bind textures to the texture units
        for use. This eliminates an ugly class of bugs involving the programmer
        using more texture units than the implementation provides and then
        failing to check <s:term type="function">glGetError()</s:term> (the
        bug may go completely unnoticed: who will notice that one texture out
        of thirty applied to an object is missing?).
      </s:paragraph>
      <s:paragraph>
        Note that textures are always backed by pixel buffers in
        <s:term type="package">jcanephora</s:term> and may therefore be
        mapped and then modified using typed cursors for trivial "streaming"
        textures.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-lwjgl/src/main/java/com/io7m/jcanephora/examples/lwjgl30/TextureExampleSimple.java" parse="text"/></s:verbatim>
      </s:formal-item>
    </s:section>
    <s:section>
      <s:section-title>Shaders</s:section-title>
      <s:paragraph>
        Diverging from the convention of showing the C program
        <s:footnote>Because the C version requires
          a large amount of support code; there's no "standard" way to
          write the same program.</s:footnote>
        and the
        <s:term type="package">jcanephora</s:term> equivalent, a complete example
        of loading a single triangle into a vertex buffer and drawing it with
        a GLSL shader:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Shaders (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-lwjgl/src/main/java/com/io7m/jcanephora/examples/lwjgl30/ShaderSimple.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Note that the APIs used above include quite a wide range of checks:
        Types of array attributes are checked against the types of program
        attributes, empty programs are rejected <s:footnote>
          Some OpenGL implementations cannot handle empty shading language
          programs, therefore they are automatically rejected by
          <s:term type="package">jcanephora</s:term> to ensure code stays
          platform-independent.
        </s:footnote>, attempting to upload data to inactive programs is
        an error, shading programs are recompiled when their source
        code is updated, compilation errors are signalled immediately and
        do not damage internal state so that the program can continue running
        using the previous shading program executable.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Framebuffers</s:section-title>
      <s:paragraph>
        This example demonstrates the use of framebuffer objects to implement
        rendering to a texture. A framebuffer is allocated, a scene rendered
        to the texture by binding the framebuffer, and then a rectangle is
        rendered using the contents of the framebuffer texture. This results
        in a simple "animated" texture.
      </s:paragraph>
      <s:paragraph>
        For simplicity, the fixed-function pipeline is used for rendering
        primitives. This should hopefully demonstrate that it's possible
        to use as much or as little of the <s:term type="package">jcanephora</s:term>
        APIs as is desired: it's always possible to drop down to the chosen
        "raw" OpenGL API.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Framebuffers (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-lwjgl/src/main/java/com/io7m/jcanephora/examples/lwjgl30/FBOExample.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Again, the API enforces consistent semantics across implementations:
        Most OpenGL implementations cannot handle multiple depth/stencil
        attachments, so only one is currently permitted. Most implementations
        cannot handle separate depth and stencil attachments, so the API
        only provides a single combined buffer. "Completeness" checks are
        made automatically on storage attachment (upon allocation of the
        framebuffer), so it's not possible to draw to a framebuffer
        configuration that OpenGL considers invalid.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external target="javadoc">Javadoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>

</s:document>
