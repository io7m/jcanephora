<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright Â© 2012 http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://www.io7m.com/schemas/structural/1.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>io7m-jcanephora 1.0.0 Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />
    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term>
          package implements a set of abstractions over
          <s:link-external target="http://opengl.org">OpenGL</s:link-external>
          with the intention of providing an API that enforces program
          correctness statically. The OpenGL API is extremely error prone, but
          thankfully most of the problems can be alleviated with the simple
          application of static types. Where the Java type system is too weak
          to give static guarantees, dynamic checks are used to prevent silent
          failure.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Correctness</s:subsection-title>
        <s:paragraph>
          Most functions in OpenGL return integers (type <s:term type="type">int</s:term>).
          The <s:term type="function">glCreateShader()</s:term> function, for example,
          returns an <s:term type="type">int</s:term> regardless of whether the function
          is creating a fragment shader or a vertex shader. Obviously, returning a different
          type depending on whether a fragment shader or a vertex shader was requested
          would require a dependent type system. As Java clearly does not have dependent types, the
          <s:term type="package">jcanephora</s:term> package
          provides a <s:term type="function">compileVertexShader()</s:term> function that
          returns a value of type <s:term type="type">VertexShader</s:term> and a
          <s:term type="function">compileFragmentShader()</s:term> function that returns
          a value of type <s:term type="type">FragmentShader</s:term>, eliminating any
          chance of confusing the two at compile-time. The package takes a similar
          approach to static safety throughout.
        </s:paragraph>
        <s:paragraph>
          All implementations of the <s:term type="package">jcanephora</s:term> API are
          run through a large battery of tests to ensure consistent semantics.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Convenience</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package also provides
          on-demand (re)compilation of GLSL shader programs via a simple
          <s:term type="type">Program</s:term> API. The package is able to load
          programs from inside archives via
          <s:link-external target="http://io7m.com/software/jvvfs">jvvfs</s:link-external>.
          The <s:term type="type">Program</s:term> API also implements a simple abstraction
          over shading program parameters (attributes, uniforms) that makes it possible
          to query the names and types of parameters at run-time.
        </s:paragraph>
        <s:paragraph>
          The package also provides a high-level API for constructing framebuffers that
          work consistently across OpenGL 3.0 and ES2 implementations.
        </s:paragraph>
        <s:paragraph>
          The package also provides functions to produce orthographic and perspective
          projection matrices, and an implementation of the ubiquitous
          <s:term type="function">lookAt()</s:term>
          function for producing a view matrix that looks at a given point in space from
          a given location.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Simplicity</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package attempts to
          provide abstractions that are as minimal as possible. It should be
          possible for any experienced OpenGL programmer to use the package
          without having to learn new concepts or fight a complicated class
          hierarchy. The idea is to provide static type safety in as simple
          a manner as possible.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Compatibility</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> exposes interfaces
          that allows developers to target the common subset of OpenGL ES2
          and OpenGL 3.*, with incompatibilities between the two indicated
          <s:term type="emphasis">statically</s:term>. This means that a
          developer using <s:term type="package">jcanephora</s:term> gets
          strong guarantees that their program will work on as many OpenGL
          implementations as possible, with implementation-specific parts
          clearly indicated by the type system.
        </s:paragraph>
        <s:paragraph>
          The package has backends
          for both <s:link-external target="http://www.jogamp.org">JOGL</s:link-external>
          and <s:link-external target="http://www.lwjgl.org">LWJGL</s:link-external>
          and presents a common API, with consistent semantics, for both.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Performance</s:subsection-title>
        <s:paragraph>
          OpenGL programs often have high performance requirements.
          The <s:term type="package">jcanephora</s:term> API abstractions
          attempt to be as cheap as possible. Operations that allocate memory or perform
          potentially expensive operations are clearly marked. Emphasis is placed on
          writing code paths that generate little in the way of garbage to be collected,
          reducing GC pressure and improving realtime performance. Many potentially expensive
          queries (such as the available number of texture units) are requested eagerly and
          cached, in order to reduce the number of OpenGL calls required at "render time".
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Source compilation</s:subsection-title>
        <s:paragraph>
          The project can be compiled and installed with
          <s:link-external target="http://maven.apache.org">Maven</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[$ mvn -C clean install]]></s:verbatim>
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Maven</s:subsection-title>
        <s:paragraph>
          Regular releases are made to the
          <s:link-external target="http://search.maven.org/#search|ga|1|jcanephora">Central Repository</s:link-external>,
          so it's possible to use the <s:term type="package">jcanephora</s:term>
          package in your projects with the following Maven dependency:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jcanephora.core</groupId>
  <artifactId>io7m-jcanephora-core</artifactId>
  <version>1.0.0</version>
</dependency>
<dependency>
  <groupId>com.io7m.jcanephora.jogl</groupId>
  <artifactId>io7m-jcanephora-jogl</artifactId>
  <version>1.0.0</version>
</dependency>
<dependency>
  <groupId>com.io7m.jcanephora.lwjgl</groupId>
  <artifactId>io7m-jcanephora-lwjgl</artifactId>
  <version>1.0.0</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
        <s:paragraph>
          Note that it is possible to omit either (but not both) of the
          <s:term type="package">jogl</s:term> or
          <s:term type="package">lwjgl</s:term> packages if your project
          does not need support for both
          <s:link-external target="http://jogamp.org">JOGL</s:link-external>
          and
          <s:link-external target="http://lwjgl.org">LWJGL</s:link-external>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Supported Systems</s:section-title>
      <s:paragraph>
        This release of the software passed 100% of the included unit tests on
        the following platforms:
      </s:paragraph>
      <s:formal-item kind="platform_table" type="platforms">
        <s:formal-item-title>Supported systems</s:formal-item-title>
        <s:table>
          <s:table-summary>Supported systems</s:table-summary>
          <s:table-head>
            <s:table-column-name>OS</s:table-column-name>
            <s:table-column-name>OS-Version</s:table-column-name>
            <s:table-column-name>OS-Arch</s:table-column-name>
            <s:table-column-name>JRE-Vendor</s:table-column-name>
            <s:table-column-name>JRE-Version</s:table-column-name>
            <s:table-column-name>JVM</s:table-column-name>
            <s:table-column-name>JVM-Vendor</s:table-column-name>
            <s:table-column-name>JVM-Version</s:table-column-name>
            <s:table-column-name>GL-Vendor</s:table-column-name>
            <s:table-column-name>GL-Renderer</s:table-column-name>
            <s:table-column-name>GL-Version</s:table-column-name>
          </s:table-head>
          <s:table-body>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.4.4-2-ARCH</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_24</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>20.0-b12</s:table-cell>
  <s:table-cell>Tungsten Graphics, Inc</s:table-cell>
  <s:table-cell>Mesa DRI Intel(R) Sandybridge Mobile </s:table-cell>
  <s:table-cell>3.0 Mesa 8.0.3</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.4.7-1-ARCH</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_24</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>20.0-b12</s:table-cell>
  <s:table-cell>X.Org</s:table-cell>
  <s:table-cell>Gallium 0.4 on AMD RV730</s:table-cell>
  <s:table-cell>2.1 Mesa 8.0.4</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.4.6-1-ARCH</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_05-icedtea</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.0-b21</s:table-cell>
  <s:table-cell>X.Org</s:table-cell>
  <s:table-cell>Gallium 0.4 on AMD BARTS</s:table-cell>
  <s:table-cell>2.1 Mesa 8.0.4</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.2.0-3-amd64</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_24</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>20.0-b12</s:table-cell>
  <s:table-cell>NVIDIA Corporation</s:table-cell>
  <s:table-cell>Quadro FX 570M/PCIe/SSE</s:table-cell>
  <s:table-cell>3.3.0 NVIDIA 302.17</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Mac OS X</s:table-cell>
  <s:table-cell>10.6.8</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Apple Inc.</s:table-cell>
  <s:table-cell>1.6.0_33</s:table-cell>
  <s:table-cell>Java HotSpot(TM) 64-Bit Server VM</s:table-cell>
  <s:table-cell>Apple Inc.</s:table-cell>
  <s:table-cell>20.8-b03-424</s:table-cell>
  <s:table-cell>ATI Technologies Inc.</s:table-cell>
  <s:table-cell>ATI Radeon HD 5670 OpenGL Engine</s:table-cell>
  <s:table-cell>2.1 ATI-1.6.36</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Windows XP</s:table-cell>
  <s:table-cell>5.1</s:table-cell>
  <s:table-cell>x86</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_05</s:table-cell>
  <s:table-cell>Java HotSpot(TM) Client VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.1-b03</s:table-cell>
  <s:table-cell>ATI Technologies Inc.</s:table-cell>
  <s:table-cell>ATI Radeon HD 4800 Series</s:table-cell>
  <s:table-cell>3.3.10362 Compatibility Profile Context</s:table-cell>
</s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:paragraph>
        There are currently no known platform-specific issues.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term type="package">jcanephora</s:term>
        package are placed under the following license:
        <s:verbatim type="license"><![CDATA[Copyright Â© 2012 http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Design/Rationale</s:part-title>
    <s:part-contents/>

    <s:section xml:id="com.io7m.jcanephora.rationale.problems">
      <s:section-title>Problems with OpenGL</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package takes the
          general view that OpenGL as an API is a ridiculously error-prone
          and poorly defined mess
          <s:footnote>
            Whilst, annoyingly, being the only viable cross-platform and
            vendor neutral graphics API available.
          </s:footnote>. The package attempts to address most if not all of
          the problems listed in this section. 
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.problems.versioning">
        <s:subsection-title>Versioning</s:subsection-title>
        <s:paragraph>
          Severely mismanaged by multiple committees since its inception,
          OpenGL has an excruciating approach to backwards compability. It 
          is only in relatively
          recent versions of OpenGL (3.0 and beyond) that features have
          actually been removed from the API. Where this has happened, the
          removals have occurred in the worst way possible: Previously valid
          function calls simply become runtime errors.
        </s:paragraph>
        <s:paragraph>
          The version numbering system for OpenGL is also apparently
          meaningless when it comes to compatibility. Developers cannot
          safely give version constraints for their programs such as
          "this program works on version <s:term type="variable">p</s:term>,
          where <s:term type="expression">4.0 &lt;= p &lt; 5.0</s:term>"
          as is standard practice for developers using some form of
          <s:link-external target="http://semver.org">semantic
          versioning</s:link-external>. OpenGL features may be deprecated
          without warning and deployed programs, without modification by
          developers, will simply stop working on newer OpenGL contexts
          <s:footnote>
            As an aside, this essentially results in an impossible situation
            for developers wanting to write programs that run on as many
            implementations as possible: They cannot ask for a
            <s:term type="emphasis">specific</s:term> version
            of OpenGL, as it may not be available. They cannot ask for any
            version <s:term type="emphasis">older</s:term> than a specific
            version, as it may not be available. They cannot ask for any
            version <s:term type="emphasis">equal to or newer</s:term> than
            a specific version, because they cannot know when the OpenGL 
            committees will deprecate or remove features. What do most programs
            do? Open a context and simply hope.
          </s:footnote>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.problems.availability">
        <s:subsection-title>Availability</s:subsection-title>
        <s:paragraph>
          At the time of writing, the most commonly available version of
          OpenGL is still 2.1. On mobile devices, the most commonly available
          version of OpenGL ES is ES2. Different drivers on the same operating
          systems result in differing degrees of support. The open-source
          <s:link-external target="http://www.x.org/wiki/radeon">radeon</s:link-external>
          driver supports up to OpenGL 3.3 on Linux. The same driver on the same
          hardware on one of the BSD operating systems will typically only
          expose the fixed-function pipeline (FreeBSD up until recently,
          would only expose OpenGL 1.3!). The same hardware, on the same
          operating system, but using the proprietary Catalystâ¢ driver from AMD,
          will typically support the latest available version of the OpenGL
          4 branch (4.3, currently). Intel GPUs on Linux platforms expose
          OpenGL ES2, OpenGL 3.0, and OpenGL 3.1.
        </s:paragraph>
        <s:paragraph>
          Developers wanting their programs to work on as many platforms as
          possible have to take extreme care to identify the portable subset
          (unless they effectively want to write the same program once for
          each version of the API
          <s:footnote>
            Not exactly ideal for an API that insists that it has excellent
            backwards compatibility.
          </s:footnote> or write insane and impossible-to-test branching
          version-specific code).
        </s:paragraph>
        <s:paragraph>
          In addition to the chaos above, drivers regularly deviate from the
          published OpenGL specifications. A developer has to know by
          <s:term type="emphasis">trial and error</s:term>, which features
          <s:term type="emphasis">do not work on any available implementations</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.problems.embedded">
        <s:subsection-title>Embedded subsets</s:subsection-title>
        <s:paragraph>
          Apparently exhausted with the complete incompetence on the part
          of the committees managing the OpenGL API, vendors began work
          on a specification for an "embedded" "subset" of the API, containing
          none of the entirely irrelevant and useless features that had been
          stubbornly carried around for years
          <s:footnote>
            The committee in charge of the OpenGL API refused to admit
            the existence of programmable graphics hardware, instead choosing
            to try to emulate features of this hardware by endlessly extending
            the fixed-function pipeline.
          </s:footnote> and represented a huge implementation burden for
          vendors without any benefit. Unfortunately, the resulting 
          API - OpenGL ES - isn't actually a subset. There are numerous
          incompatibilities, meaning that while OpenGL 3.0 and ES2 programs
          are "mostly compatible", they're incompatible in a few fundamental
          areas. Obviously, these incompatibilities aren't discovered by the
          developer until runtime.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.problems.types">
        <s:subsection-title>Types</s:subsection-title>
        <s:paragraph>
          The OpenGL API itself is weakly typed even for a C language API, simply
          exposing absolutely everything as a <s:term type="type">float</s:term>,
          <s:term type="type">int</s:term>, or untyped pointer. Entire classes
          of problems that should be prevented at compile time are moved to
          run-time, increasing development time, developer frustration, and
          testing burden.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.problems.silent_failure">
        <s:subsection-title>Silent failure</s:subsection-title>
        <s:paragraph>
          OpenGL programs frequently fail, and when they do, they usually do
          so silently. Programmers are forced to call
          <s:term type="function">glGetError</s:term> after every API call
          if they wish to avoid this (and actually detect the error at the
          correct function call).
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section>
      <s:section-title>Goals</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          Given the
          <s:link target="com.io7m.jcanephora.rationale.problems">problems</s:link>
          with OpenGL, the <s:term type="package">jcanephora</s:term> package
          has the following goals (in no particular order):
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.goals.portability">
        <s:subsection-title>Portability</s:subsection-title>
        <s:paragraph>
          Programs using the <s:term type="package">jcanephora</s:term> APIs
          must run on as many different OpenGL implementations as possible.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.goals.type_safety">
        <s:subsection-title>Type safety</s:subsection-title>
        <s:paragraph>
          Representing every object as an integer is unacceptable. Any
          conceptually distinct objects must be made type-incompatible,
          eliminating entire classes of bugs typical to OpenGL programs
          at compile time.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.goals.linearity">
        <s:subsection-title>Linearity</s:subsection-title>
        <s:paragraph>
          Branching, version-specific code must be eliminated as far as
          is possible. Code of this type is fragile, difficult to test,
          and usually incorrect.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.goals.conspicuity">
        <s:subsection-title>Conspicuity of errors</s:subsection-title>
        <s:paragraph>
          Silent failure of programs is unacceptable. All errors that
          cannot be prevented statically must be loudly and immediately
          signalled at runtime.
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section>
      <s:section-title>API Design</s:section-title>
      <s:subsection xml:id="com.io7m.jcanephora.rationale.solutions.interfaces">
        <s:subsection-title>Interfaces</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package attempts
          to combat the problems with OpenGL's idea of
          <s:link target="com.io7m.jcanephora.rationale.problems.versioning">versioning</s:link>,
          the actual
          <s:link target="com.io7m.jcanephora.rationale.problems.availability">availability</s:link>
          of implementations, and the presence of
          <s:link target="com.io7m.jcanephora.rationale.problems.embedded">embedded not-actually-subsets</s:link>
          of the API, by identifying the most widely-deployed versions of OpenGL
          at present (OpenGL 2.1, OpenGL 3.1, and ES2) and then
          by identifying the non-deprecated, arguably future-proof, and common
          subset of the versions in question.
        </s:paragraph>
        <s:paragraph>
          The package then provides interface types that expose the functionality of 
          varying parts of this common subset. Developers know, unambiguously,
          on which versions of OpenGL their code will run simply by looking at
          the interface types their code uses. The package tends to only
          provide those things that are required to be provided according to
          the OpenGL specification. Exceptions to this rule are made when,
          for example,  OpenGL driver limitations force the use of extensions.
        </s:paragraph>
        <s:paragraph>
          The developer interacts with the 
          <s:term type="package">jcanephora</s:term> package via the
          <s:link-external target="javadoc/com/io7m/jcanephora/GLImplementation.html">GLImplementation</s:link-external>
          type. The <s:term type="type">GLImplementation</s:term> type,
          unsurprisingly, represents the current OpenGL implementation. The
          <s:term type="type">GLImplementation</s:term> type allows access
          to interfaces such as
          <s:link-external target="javadoc/com/io7m/jcanephora/GLInterfaceGLES2.html">GLInterfaceGLES2</s:link-external>
          (if the current implementation provides OpenGL ES2),
          <s:link-external target="./io7m-jcanephora-core/src/main/java/com/io7m/jcanephora/GLInterfaceGL3.html">GLInterfaceGL3</s:link-external>
          (if the current implementation provides OpenGL 3.*), and
          also to
          <s:link-external target="javadoc/com/io7m/jcanephora/GLInterfaceCommon.html">GLInterfaceCommon</s:link-external>,
          representing the common subset of both.
        </s:paragraph>
        <s:paragraph>
          The <s:term type="type">GLInterface</s:term> types statically
          control access to features of the current OpenGL implementation and
          essentially aggregate a set of smaller interfaces. For example,
          the
          <s:link-external target="javadoc/com/io7m/jcanephora/GLArrayBuffers.html">GLArrayBuffers</s:link-external>
          interface represents the
          <s:link-external target="http://opengl.org/wiki/Vertex_Buffer_Object">vertex buffer object</s:link-external>
          functionality common to both OpenGL 3.* and OpenGL ES2. The
          <s:link-external target="javadoc/com/io7m/jcanephora/GLArrayBuffersMapped.html">GLArrayBuffersMapped</s:link-external>
          interface, however, provides the extra functionality only supported
          by OpenGL 3.* and is therefore not available via the
          <s:term type="type">GLInterfaceGLES2</s:term> interface.
        </s:paragraph>
        <s:paragraph>
          An extremely useful consequence of the way that the
          <s:term type="package">jcanephora</s:term> interfaces are structured
          is that developers can indicate at the level of types which versions
          of OpenGL their code can work with. They can even go so far as to
          specify these dependencies at the granularity of features
          ("this code will work with any OpenGL implementation supporting
          unmapped vertex buffer objects, and 2D textures"):
        </s:paragraph>
        <s:formal-item type="implications" kind="implications">
          <s:formal-item-title>Compatibility implications of interfaces</s:formal-item-title>
          <s:table>
            <s:table-summary>Compatibility implications of interfaces</s:table-summary>
            <s:table-head>
              <s:table-column-name>The developer writes a function parameterized by:</s:table-column-name>
              <s:table-column-name>This implies:</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:verbatim>GLImplementation</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>GLInterfaceGLES2</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL ES2 implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>GLInterfaceGL3</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL 3.* implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>G extends GLArrayBuffers &amp; GLTextures2DStaticCommon</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any implementation supporting vertex buffer objects and 2D textures</s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          The interfaces described in this section contribute towards
          the goals of <s:link target="com.io7m.jcanephora.rationale.goals.portability">portability</s:link>
          and
          <s:link target="com.io7m.jcanephora.rationale.goals.type_safety">type safety</s:link>.
        </s:paragraph>
      </s:subsection>
      
      <s:subsection xml:id="com.io7m.jcanephora.rationale.solutions.capabilities">
        <s:subsection-title>Interfaces as capabilities</s:subsection-title>
        <s:paragraph>
          The package is written with one particular concept, throughout:
          Types represent capabilities. If the developer has a value of a
          given type, then the developer can perform all of the operations
          associated with that type. This is a direct attempt at the goal
          of <s:link target="com.io7m.jcanephora.rationale.goals.linearity">linearity</s:link>.
        </s:paragraph>
        <s:paragraph>
          This is in direct contrast to the OpenGL
          API, where the developer always has full access to all API functions,
          and individual functions (or combinations of parameters to functions)
          may not work based on what the implementation supports. The emphasis
          is on <s:term type="emphasis">isolating the correct operations and
          statically preventing incorrect operations from occurring</s:term>.
        </s:paragraph>
        <s:paragraph>
          One example of the "capability" based design is the
          <s:link-external target="javadoc/com/io7m/jcanephora/GLRenderbuffersGL3.html">GLRenderbuffersGL3</s:link-external>
          and
          <s:link-external target="javadoc/com/io7m/jcanephora/GLRenderbuffersGLES2.html">GLRenderbuffersGLES2</s:link-external>
          interfaces. The specifications for OpenGL ES2 and OpenGL 3.0 do
          not require a color-renderable framebuffer format that is common
          to both. Therefore, the <s:term type="type">GLRenderbuffersGL3</s:term>
          interface allows the allocation of texture types specific to OpenGL 3.0,
          and the <s:term type="type">GLRenderbuffersGLES2</s:term> interface
          provides texture types specific to OpenGL ES2. A developer using
          the package will be presented with an
          <s:term type="type">GLRenderbuffersGL3</s:term> interface when code
          is running on OpenGL 3.0, and an
          <s:term type="type">GLRenderbuffersGLES2</s:term> interface when
          code is running on OpenGL ES2, thus
          <s:term type="emphasis">statically preventing an attempt to allocate an unsupported format</s:term>.
          Of course, some ES2 and 3.0 implementations do have color-renderable
          formats in common, but a portable program cannot assume this as it
          is not required by the OpenGL specification
          <s:footnote>
            The <s:term type="package">jcanephora</s:term> package
            also provides higher level abstractions such as the
            <s:link-external target="javadoc/com/io7m/jcanephora/FramebufferConfigurationGLES2.html">FramebufferConfigurationGLES2</s:link-external>
            interface, which takes a set of abstract properties such as "must have a color buffer"
            and "must have a depth buffer" and produces a framebuffer that will
            be usable on all OpenGL versions. A similar interface,
            <s:link-external target="javadoc/com/io7m/jcanephora/FramebufferConfigurationGL3.html">FramebufferConfigurationGL3</s:link-external>,
            produces framebuffers that are not expected to work on OpenGL ES2
            (as the OpenGL 3.* framebuffers are far more feature-rich and
            no equivalent functionality exists on ES2).
          </s:footnote>.
        </s:paragraph>
      </s:subsection>
      
      <s:subsection xml:id="com.io7m.jcanephora.rationale.solutions.types">
        <s:subsection-title>Types</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package wraps all
          conceptually distinct objects in new types and provides sane and
          unsurprising functions to construct them. This prevents large
          classes of bugs from occurring, at compile time. It also allows
          the interfaces to be self-documenting. Consider the following
          C function prototype:
        </s:paragraph>
        <s:formal-item kind="example">
          <s:formal-item-title>Weakly typed C function</s:formal-item-title>
          <s:verbatim>void _ (GLsizei, GLuint *)</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          What does the function do? It could generate a set of textures
          (<s:term type="function">glGenTextures</s:term>), or it could
          generate a set of new buffer names
          (<s:term type="function">glGenBuffers</s:term>). Without carefully
          reading the documentation, the required parameters to the function
          are certainly not obvious from the type alone. Assuming the developer
          has read the documentation and worked out that the correct way to
          call the function is with the following sequence:
        </s:paragraph>
        <s:formal-item kind="example">
          <s:formal-item-title>Weakly typed C calls</s:formal-item-title>
          <s:verbatim><![CDATA[GLuint texture;

glGenTextures(1, &texture);
checkGLErrors();]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The developer now has a value of type
          <s:term type="type">GLuint</s:term>. Given that many functions in
          the OpenGL API also take values of <s:term type="type">GLuint</s:term>,
          and those values have nothing to do with textures, that's a huge
          number of potential bugs that cannot be prevented by the compiler.
        </s:paragraph>
        <s:paragraph>
          The developer now wants to allocate a new RGBA texture. The
          types of the <s:term type="function">glTexImage2D</s:term>
          and <s:term type="function">glTexParameteri</s:term> functions
          are, quite frankly, insane. Almost no developer manages to use these
          functions successfully without trial and error, and naturally all
          errors are runtime errors. Eventually, through some painful
          experimentation, the developer might stumble onto the following
          sequence of calls:
        </s:paragraph>
        <s:formal-item kind="example">
          <s:formal-item-title>Allocating a texture</s:formal-item-title>
          <s:verbatim><![CDATA[GLuint texture;
void *data = makeTextureData();

glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The types of the parameters to all of the functions mentioned allow
          the developer to pass in practically anything. Only a very small
          subset of the possible parameters are actually valid.
        </s:paragraph>
        <s:paragraph> 
          Now consider the
          following <s:term type="package">jcanephora</s:term> function:
        </s:paragraph>
        <s:formal-item kind="example">
          <s:formal-item-title>Texture allocation?</s:formal-item-title>
          <s:verbatim><![CDATA[public @Nonnull Texture2DStatic _(
  final @Nonnull String _,
  final int _,
  final int _,
  final @Nonnull TextureWrapS _,
  final @Nonnull TextureWrapT _,
  final @Nonnull TextureFilterMinification _,
  final @Nonnull TextureFilterMagnification _)
    throws ConstraintError,
      GLException;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Even without the names of the function and the parameters,
          the type above make it quite clear that the function returns a
          <s:term type="type">Texture2DStatic</s:term>, which is somehow
          derived from the arguments to the function. It's a reasonable
          assumption to make that the function allocates a new texture.
        </s:paragraph>
        <s:paragraph>
          The wrapping modes on the <s:term type="constant">S</s:term> and
          <s:term type="constant">T</s:term> axis will presumably be
          derived from the parameters of type
          <s:term type="type">TextureWrapS</s:term> and
          <s:term type="type">TextureWrapT</s:term> respectively. The
          minification and magnification filters will presumably be derived
          from the parameters of type
          <s:term type="type">TextureFilterMinification</s:term> and
          <s:term type="type">TextureFilterMagnification</s:term>,
          respectively. The programmer is statically prevented from mixing
          up the two axes, or the two filter domains.
        </s:paragraph>
        <s:paragraph>
          The two parameters of type <s:term type="type">int</s:term>
          presumably correspond to the width and height of the resulting
          texture, but the types are not descriptive enough to say for sure.
          Unfortunately, Java lacks a way to make existing arithmetic types
          incompatible without sacrificing efficiency
          <s:footnote>
            New types will be new classes, resulting in all integers being
            replaced with pointers to integers.
          </s:footnote>. In this case, the two parameters do indeed
          correspond to the width and height, in that order, and the
          <s:term type="package">jcanephora</s:term> package uses this
          order consistently throughout.
        </s:paragraph>
        <s:paragraph>
          The annotations on the parameters indicate that passing
          <s:term type="constant">null</s:term> for any parameter is an
          error. The Java compiler cannot currently statically prevent this,
          but the
          <s:link-external target="http://findbugs.sourceforge.net">findbugs</s:link-external>
          tool can. The annotation on the return type also indicates that
          the function will always return a 
          non-<s:term type="constant">null</s:term> result. This implies that
          either the function will return a correct and complete result,
          or it will raise an exception.
        </s:paragraph>
        <s:paragraph>
          The errors that the function may raise are also clearly marked as
          checked exceptions.
        </s:paragraph>
        <s:paragraph>
          Some information is still missing, of course, such as the format
          (such as 32-bit RGBA) and type (such as 2D or cube map) of the
          resulting texture. The full name and type of the function is given
          in the
          <s:link-external target="javadoc/com/io7m/jcanephora/GLTextures2DStaticCommon.html">GLTextures2DStaticCommon</s:link-external>
          interface:
        </s:paragraph>
        <s:formal-item kind="example">
          <s:formal-item-title>texture2DStaticAllocateRGBA8888</s:formal-item-title>
          <s:verbatim><![CDATA[public @Nonnull Texture2DStatic texture2DStaticAllocateRGBA8888(
  final @Nonnull String name,
  final int width,
  final int height,
  final @Nonnull TextureWrapS wrap_s,
  final @Nonnull TextureWrapT wrap_t,
  final @Nonnull TextureFilterMinification min_filter,
  final @Nonnull TextureFilterMagnification mag_filter)
    throws ConstraintError,
      GLException;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The function allocates a 2D RGBA texture with
          <s:term type="constant">8</s:term> bits of precision per channel.
          The texture will be <s:term type="variable">width</s:term> texels
          wide, and <s:term type="variable">height</s:term> texels tall. The
          texture will be assigned the name
          <s:term type="variable">name</s:term>, useful for debugging and
          logging (by convention, this is the filename containing the original
          texture's image, if any).
        </s:paragraph>
        <s:paragraph>
          The extremely descriptive type given for the function, and the
          presence of checked exceptions are direct contributions towards
          the goals of
          <s:link target="com.io7m.jcanephora.rationale.goals.type_safety">type safety</s:link>
          and
          <s:link target="com.io7m.jcanephora.rationale.goals.conspicuity">conspicuity of errors</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>jcanephora For OpenGL Programmers</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        As stated repeatedly, the <s:term type="package">jcanephora</s:term>
        package strives for increased static and run-time type safety. This
        does, however, mean that there are new abstractions to learn. This
        section of the documentation attempts to describe how to use the API
        for those already familiar with OpenGL. It presents small programs
        written in C and then shows the <s:term type="package">jcanephora</s:term>
        equivalent. For the sake of brevity, the C programs often use the
        obsolete fixed-function pipeline (otherwise each example would have
        to implement a lot of tedious matrix math and shading program
        management).
      </s:paragraph>
      <s:paragraph>
        Every <s:term type="package">jcanephora</s:term> program begins
        by retrieving an implementation of the
        <s:link-external target="javadoc/com/io7m/jcanephora/GLImplementation.html">GLImplementation</s:link-external>
        interface. At the time of writing, there are implementations based on
        <s:link-external target="http://lwjgl.org">LWJGL</s:link-external>
        and
        <s:link-external target="http://jogamp.org">JOGL</s:link-external>.
        Programs are insulated from the platform/implementation specific
        details of the OpenGL interface via the
        interface types - all operations occur via values of these types and
        client programs do not know anything about the underlying OpenGL
        implementation.
      </s:paragraph>
      <s:paragraph>
        The programmer is expected to know how to initialize either of
        <s:link-external target="http://lwjgl.org">LWJGL</s:link-external>
        or
        <s:link-external target="http://jogamp.org">JOGL</s:link-external>:
        the details are obviously outside of the scope of this
        documentation. Once initialized, the programmer can then use
        the constructors of any of the implementations of
        <s:term type="function">GLImplementation</s:term>
        to get access to the <s:term type="package">jcanephora</s:term>
        APIs.
      </s:paragraph>
      <s:paragraph>
        Beyond the APIs exposed by <s:term type="function">GLImplementation</s:term>,
        the <s:term type="package">jcanephora</s:term> package also provides
        various higher level abstractions, such as on-demand shader
        compilation with
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>,
        matrix manipulation with
        <s:link-external target="javadoc/com/io7m/jcanephora/ProjectionMatrix.html">ProjectionMatrix</s:link-external>,
        implementation-independent framebuffer creation with
        <s:link-external target="javadoc/com/io7m/jcanephora/FramebufferConfigurationGLES2.html">FramebufferConfigurationGLES2</s:link-external>
        and
        <s:link-external target="javadoc/com/io7m/jcanephora/FramebufferConfigurationGL3.html">FramebufferConfigurationGL3</s:link-external>,
        See the <s:link-external target="javadoc/index.html">Javadoc</s:link-external>
        for details.
      </s:paragraph>
    </s:section>
    <s:section xml:id="com.io7m.jcanephora.tutorial_vbo">
      <s:section-title>Vertex Buffer Objects</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="vbo.c">vbo.c</s:link-external>]
        demonstrates the creation of vertex buffer and index buffer objects
        in plain OpenGL. It creates buffers and then draws them to the screen
        using the fixed-function OpenGL pipeline.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffers (C)</s:formal-item-title>
        <s:verbatim><xi:include href="../c/two-triangles.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> version demonstrates
        many of the package's convenience and safety features:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffers (Java)</s:formal-item-title>
        <s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleTriangle.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The program creates a new shading language program with the
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>
        interface. This interface gives easy and type-safe access to the uniform and
        attribute variables present in the program.
      </s:paragraph>
      <s:paragraph>
        The program allocates an
        <s:link-external target="javadoc/com/io7m/jcanephora/ArrayBuffer.html">array buffer</s:link-external>
        by creating an explicit description of the type of its elements with an
        <s:link-external target="javadoc/com/io7m/jcanephora/ArrayBufferDescriptor.html">ArrayBufferDescriptor</s:link-external>,
        and then allocating a given number of them.
      </s:paragraph>
      <s:paragraph>
        Using the type information given when the array buffer was created, the program
        obtains access to the elements of the array by using typed
        <s:link-external target="javadoc/com/io7m/jcanephora/Cursor.html">Cursors</s:link-external>.
        The cursors
        can only point to the specific attributes for which they are intended and refuse
        attempts to write to memory outside of the array data. The cursors also check the
        types of their intended attributes on creation and loudly refuse attempts to write
        to attributes that do not have the expected type. These features eliminate large
        classes of bugs usually associated with doing this kind of low-level memory
        management in C.
      </s:paragraph>
      <s:paragraph>
        The program allocates an
        <s:link-external target="javadoc/com/io7m/jcanephora/IndexBuffer.html">index buffer</s:link-external>
        by using the array buffer as a hint. This
        allows the <s:term type="package">jcanephora</s:term> package to pick the most
        efficient type for individual indices: If an array buffer has fewer than 256 vertices,
        for example, then there is no reason for the index buffer to use two or four-byte
        indices. This gives significant GPU memory savings whilst presenting a uniform
        interface to the programmer. It is also possible for the programmer to specify
        index buffer types directly, but that is not shown here.
      </s:paragraph>
      <s:paragraph>
        The program passes uniform values to the program over a simple and type-checked
        analogue to the <s:term type="function">glUniform*</s:term> interface. Attempting
        to pass a value of the wrong type is prevented at run-time.
      </s:paragraph>
      <s:paragraph>
        The program associates array buffer attributes with program attributes using
        a type-safe interface.
      </s:paragraph>
      <s:paragraph>
        In all cases, the API also tracks whether or not objects have been deleted
        (using a simple flag on the client side), and loudly signals when OpenGL resources
        that have been deleted are passed to various API functions. It would be an error,
        for example, to call the <s:term type="function">drawElements</s:term> function
        pictured when the array or index buffer had been deleted.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Textures</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="texture-simple.c">texture-simple.c</s:link-external>]
        demonstrates the creation and usage of textures. It generates a simple
        texture and displays it on a rectangle. The program uses the obsolete fixed-function
        pipeline for brevity, as previously mentioned.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (C)</s:formal-item-title>
        <s:verbatim><xi:include href="../c/texture-simple.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> version again demonstrates
        many of the package's convenience and safety features:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleTexturedQuad.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        In addition to the features demonstrated in the
        <s:link target="com.io7m.jcanephora.tutorial_vbo">previous example</s:link>, the
        program demonstrates a number of features specific to texturing.
      </s:paragraph>
      <s:paragraph>
        The program requests access to a list of the available texture units. This
        eliminates a class of bugs present in many programs that use
        <s:term type="function">glActiveTexture</s:term>: Most implementations support
        between 16-32 texture units, at the time of writing. OpenGL will raise an error
        if a program attempts to use more than the available number of units, but most
        programs also fail to check OpenGL error codes. The design of the
        <s:term type="package">jcanephora</s:term> API models texture units as concrete
        objects of type
        <s:link-external target="javadoc/com/io7m/jcanephora/TextureUnit.html">TextureUnit</s:link-external>
        and therefore programs cannot accidentally use more units than the implementation
        provides.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> hides the ridiculously complicated,
        type-unsafe and legacy-ridden <s:term type="function">glTexImage2D</s:term>,
        <s:term type="function">glTexSubImage2D</s:term>, and
        <s:term type="function">glTexParameter</s:term> interfaces
        and instead exposes a simple allocation function that takes values of various
        <s:term type="keyword">enum</s:term> types specifying the exact properties of the
        texture to be allocated. The texture type information is stored (client side) along
        with the details of the allocated texture, allowing type-safe access to texture data
        later on. Many of the combinations of parameters to the raw OpenGL functions
        are invalid, according to the OpenGL specifications. This API rejects the
        invalid combinations statically.
      </s:paragraph>
      <s:paragraph>
        The program updates the allocated texture by creating a new
        <s:link-external target="javadoc/com/io7m/jcanephora/Texture2DWritableData.html">client-side buffer of data</s:link-external>
        and then obtaining access to the data via a
        <s:link-external target="javadoc/com/io7m/jcanephora/SpatialCursor.html">typed cursor</s:link-external>
        interface. It is an error to try to obtain a cursor of the
        wrong type (such as requesting a cursor that points to
        four-component elements in a texture that only contains
        a luminance and alpha channel, for example). The cursor
        interface exposes a uniform interface with regards to color
        data and performs automatic conversion/color packing - the
        program works with simple linear RGBA color values and does
        not need to worry about converting/packing those values into
        the correct format for the texture.
      </s:paragraph>
      <s:paragraph>
        Finally, during rendering, the program binds the texture to a texture unit and
        uploads the name of the texture unit to the shading language program. Naturally,
        all of these operations have increased type safety (it's not possible to upload
        an arbitrary integer to a program that expects a
        <s:term type="type">sampler2D</s:term> type, for example).
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Shaders</s:section-title>
      <s:paragraph>
        The
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>
        interface is actually a higher-level abstraction to a low-level shading
        program interface.
      </s:paragraph>
      <s:paragraph>
        Diverging from the convention of showing the C program
        <s:footnote>Because the C version requires
          a large amount of support code; there's no "standard" way to
          write the same program.</s:footnote>
        and the
        <s:term type="package">jcanephora</s:term> equivalent, a complete example
        of loading a single triangle into a vertex buffer and drawing it with
        a GLSL shader, using the low-level shading language interface:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Shaders (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleShaders.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>
        interface is recommended as it implements a wide array of safety
        and convenience features:
        Empty programs are rejected <s:footnote>
          Some OpenGL implementations cannot handle empty shading language
          programs, therefore they are automatically rejected by
          <s:term type="package">jcanephora</s:term> to ensure code stays
          platform-independent.
        </s:footnote>, attempting to upload data to inactive programs is
        an error, shading programs are recompiled when their source
        code is updated, compilation errors are signalled immediately and
        do not damage internal state so that the program can continue running
        using the previous shading program executable.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Framebuffers</s:section-title>
      <s:paragraph>
        This example demonstrates the use of framebuffer objects to implement
        rendering to a texture. A framebuffer is allocated, a scene rendered
        to the texture by binding the framebuffer, and then a rectangle is
        rendered using the contents of the framebuffer texture. This results
        in a simple "animated" texture.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Framebuffers (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleFBO.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Again, the API enforces consistent semantics across implementations:
        Most OpenGL implementations cannot handle multiple depth/stencil
        attachments, so only one is currently permitted. Most current
        implementations cannot handle separate depth and stencil attachments,
        so the API only provides a
        <s:link-external target="javadoc/com/io7m/jcanephora/RenderbufferD24S8.html">single combined buffer</s:link-external>.
        "Completeness" checks are
        made automatically on storage attachment (upon allocation of the
        framebuffer), so it's not possible to draw to a framebuffer
        configuration that OpenGL considers invalid.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Everything Else</s:section-title>
      <s:paragraph>
        Modern OpenGL programming consists of little more than vertex buffer
        objects, shaders, and framebuffer objects, and the
        <s:term type="package">jcanephora</s:term> API reflects this.
      </s:paragraph>
      <s:paragraph>
        The rest of the <s:term type="package">jcanephora</s:term>
        API is concerned with adding type safety to the functions that
        work on the other parts of the OpenGL pipeline. The following
        table lists the <s:term type="package">jcanephora</s:term>
        equivalents of OpenGL features.
      </s:paragraph>
      <s:formal-item kind="feature_mapping" type="feature_mapping">
        <s:formal-item-title>Features</s:formal-item-title>
        <s:table>
          <s:table-summary>OpenGL/jcanephora feature mapping</s:table-summary>
          <s:table-head>
            <s:table-column-name>OpenGL</s:table-column-name>
            <s:table-column-name>jcanephora</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term type="function">glBlendFunc</s:term></s:table-cell>
              <s:table-cell>
                <s:link-external target="javadoc/com/io7m/jcanephora/GLBlending.html">GLBlending</s:link-external>,
                <s:link-external target="javadoc/com/io7m/jcanephora/GLBlendingEmbedded.html">GLBlendingEmbedded</s:link-external>
              </s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Vertex buffer objects</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLArrayBuffers.html">GLArrayBuffers</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Mapped vertex buffer objects (glMapBuffer)</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLArrayBuffersMapped.html">GLArrayBuffersMapped</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glClear</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLColorBuffer.html">GLColorBuffer</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glCullFace</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLCull.html">GLCull</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glDepthFunc</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLDepthBuffer.html">GLDepthBuffer</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glDrawElements</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLDraw.html">GLDraw</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glGetError</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLMeta.html">GLMeta</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Index buffer objects</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLIndexBuffers.html">GLIndexBuffers</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Mapped index buffer objects (glMapBuffer)</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLIndexBuffersMapped.html">GLIndexBuffersMapped</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glLogicOp</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLLogic.html">GLLogic</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glPolygonMode</s:term>, etc</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLPolygonModes.html">GLPolygonModes</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glLineWidth</s:term>, etc</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLRasterization.html">GLRasterization</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glScissor</s:term>, <s:term type="function">glScissor</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLScissor.html">GLScissor</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glStencil</s:term>, <s:term type="function">glStencil</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLStencilBuffer.html">GLStencilBuffer</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Textures (<s:term type="function">glTexImage2D</s:term>)</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLTextures2DStaticCommon.html">GLTextures2DStaticCommon</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glViewport</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLViewport.html">GLViewport</s:link-external></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external target="javadoc">Javadoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>

</s:document>
