<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright Â© 2012 http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://www.io7m.com/schemas/structural/1.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>io7m-jcanephora 1.0.0 Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />
    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term>
          package implements a set of abstractions over
          <s:link-external target="http://opengl.org">OpenGL</s:link-external>
          with the intention of providing an API that enforces program
          correctness statically. The OpenGL API is extremely error prone, but
          thankfully most of the problems can be alleviated with the simple
          application of static types. Where the Java type system is too weak
          to give static guarantees, dynamic checks are used to prevent silent
          failure.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Correctness</s:subsection-title>
        <s:paragraph>
          Most functions in OpenGL return integers (type <s:term type="type">int</s:term>).
          The <s:term type="function">glCreateShader()</s:term> function, for example,
          returns an <s:term type="type">int</s:term> regardless of whether the function
          is creating a fragment shader or a vertex shader. Obviously, returning a different
          type depending on whether a fragment shader or a vertex shader was requested
          would require a dependent type system. As Java clearly does not have dependent types, the
          <s:term type="package">jcanephora</s:term> package
          provides a <s:term type="function">compileVertexShader()</s:term> function that
          returns a value of type <s:term type="type">VertexShader</s:term> and a
          <s:term type="function">compileFragmentShader()</s:term> function that returns
          a value of type <s:term type="type">FragmentShader</s:term>, eliminating any
          chance of confusing the two at compile-time. The package takes a similar
          approach to static safety throughout.
        </s:paragraph>
        <s:paragraph>
          All implementations of the <s:term type="package">jcanephora</s:term> API are
          run through a large battery of tests to ensure consistent semantics.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Convenience</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package also provides
          on-demand (re)compilation of GLSL shader programs via a simple
          <s:term type="type">Program</s:term> API. The package is able to load
          programs from inside archives via
          <s:link-external target="http://io7m.com/software/jvvfs">jvvfs</s:link-external>.
          The <s:term type="type">Program</s:term> API also implements a simple abstraction
          over shading program parameters (attributes, uniforms) that makes it possible
          to query the names and types of parameters at run-time.
        </s:paragraph>
        <s:paragraph>
          The package also provides functions to produce orthographic and perspective
          projection matrices, and an implementation of the ubiquitous
          <s:term type="function">lookAt()</s:term>
          function for producing a view matrix that looks at a given point in space from
          a given location.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Simplicity</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package attempts to
          provide abstractions that are as minimal as possible. It should be
          possible for any experienced OpenGL programmer to use the package
          without having to learn new concepts or fight a complicated class
          hierarchy. The idea is to provide static type safety in as simple
          a manner as possible.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Portability</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package has backends
          for both <s:link-external target="http://www.jogamp.org">JOGL</s:link-external>
          and <s:link-external target="http://www.lwjgl.org">LWJGL</s:link-external>
          and presents a common API, with consistent semantics, for both.
        </s:paragraph>
        <s:paragraph>
          At the time of writing, the most widely supported version of OpenGL is 2.1 and the
          most widely supported version of OpenGL ES is 2. The version of OpenGL that
          followed, 3.0, was the first version to actually deprecate/remove
          obsolete features such as the fixed-function pipeline. The
          <s:term type="package">jcanephora</s:term> API and implementation therefore
          only uses those features of 3.0 that are also present in 2.1, and does not
          use any deprecated and/or obsolete features. It also provides an "embedded" API
          that essentially represents the capabilities of OpenGL ES 2. This allows programs
          using <s:term type="package">jcanephora</s:term> to run unmodified on just about
          any desktop/workstation graphics hardware produced in the last ten years or
          so. Programs written against the
          <s:link-external target="javadoc/com/io7m/jcanephora/GLInterfaceEmbedded.html">GLInterfaceEmbedded</s:link-external>
          interface can be assumed to run unmodified on any OpenGL 2.1+, 3.0+ or ES2+
          implementation
          <s:footnote>
            Barring any incompatibilities in shading language programs, which are
            outside of the scope of <s:term type="package">jcanephora</s:term>.
          </s:footnote>. Programs written against the
          <s:link-external target="javadoc/com/io7m/jcanephora/GLInterface.html">GLInterface</s:link-external>
          interface can be assumed to run unmodified on any OpenGL 2.1+ or 3.0+
          implementation
          <s:footnote>
            Again, barring any incompatibilities in shading language programs.
          </s:footnote>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Performance</s:subsection-title>
        <s:paragraph>
          OpenGL programs often have high performance requirements.
          The <s:term type="package">jcanephora</s:term> API abstractions
          attempt to be as cheap as possible. Operations that allocate memory or perform
          potentially expensive operations are clearly marked. Emphasis is placed on
          writing code paths that generate little in the way of garbage to be collected,
          reducing GC pressure and improving realtime performance. Many potentially expensive
          queries (such as the available number of texture units) are requested eagerly and
          cached, in order to reduce the number of OpenGL calls required at "render time".
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Source compilation</s:subsection-title>
        <s:paragraph>
          The project can be compiled and installed with
          <s:link-external target="http://maven.apache.org">Maven</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[$ mvn -C clean install]]></s:verbatim>
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Maven</s:subsection-title>
        <s:paragraph>
          Regular releases are made to the
          <s:link-external target="http://search.maven.org/#search|ga|1|jcanephora">Central Repository</s:link-external>,
          so it's possible to use the <s:term type="package">jcanephora</s:term>
          package in your projects with the following Maven dependency:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jcanephora.core</groupId>
  <artifactId>io7m-jcanephora-core</artifactId>
  <version>1.0.0</version>
</dependency>
<dependency>
  <groupId>com.io7m.jcanephora.jogl</groupId>
  <artifactId>io7m-jcanephora-jogl</artifactId>
  <version>1.0.0</version>
</dependency>
<dependency>
  <groupId>com.io7m.jcanephora.lwjgl</groupId>
  <artifactId>io7m-jcanephora-lwjgl</artifactId>
  <version>1.0.0</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
        <s:paragraph>
          Note that it is possible to omit either (but not both) of the
          <s:term type="package">jogl</s:term> or
          <s:term type="package">lwjgl</s:term> packages if your project
          does not need support for both
          <s:link-external target="http://jogamp.org">JOGL</s:link-external>
          and
          <s:link-external target="http://lwjgl.org">LWJGL</s:link-external>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Supported Systems</s:section-title>
      <s:paragraph>
        This release of the software passed 100% of the included unit tests on
        the following platforms:
      </s:paragraph>
      <s:formal-item kind="platform_table" type="platforms">
        <s:formal-item-title>Supported systems</s:formal-item-title>
        <s:table>
          <s:table-summary>Supported systems</s:table-summary>
          <s:table-head>
            <s:table-column-name>OS</s:table-column-name>
            <s:table-column-name>OS-Version</s:table-column-name>
            <s:table-column-name>OS-Arch</s:table-column-name>
            <s:table-column-name>JRE-Vendor</s:table-column-name>
            <s:table-column-name>JRE-Version</s:table-column-name>
            <s:table-column-name>JVM</s:table-column-name>
            <s:table-column-name>JVM-Vendor</s:table-column-name>
            <s:table-column-name>JVM-Version</s:table-column-name>
            <s:table-column-name>GL-Vendor</s:table-column-name>
            <s:table-column-name>GL-Renderer</s:table-column-name>
            <s:table-column-name>GL-Version</s:table-column-name>
          </s:table-head>
          <s:table-body>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.4.4-2-ARCH</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_24</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>20.0-b12</s:table-cell>
  <s:table-cell>Tungsten Graphics, Inc</s:table-cell>
  <s:table-cell>Mesa DRI Intel(R) Sandybridge Mobile </s:table-cell>
  <s:table-cell>3.0 Mesa 8.0.3</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.4.7-1-ARCH</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_24</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>20.0-b12</s:table-cell>
  <s:table-cell>X.Org</s:table-cell>
  <s:table-cell>Gallium 0.4 on AMD RV730</s:table-cell>
  <s:table-cell>2.1 Mesa 8.0.4</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.4.6-1-ARCH</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_05-icedtea</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.0-b21</s:table-cell>
  <s:table-cell>X.Org</s:table-cell>
  <s:table-cell>Gallium 0.4 on AMD BARTS</s:table-cell>
  <s:table-cell>2.1 Mesa 8.0.4</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Linux</s:table-cell>
  <s:table-cell>3.2.0-3-amd64</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>1.6.0_24</s:table-cell>
  <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
  <s:table-cell>Sun Microsystems Inc.</s:table-cell>
  <s:table-cell>20.0-b12</s:table-cell>
  <s:table-cell>NVIDIA Corporation</s:table-cell>
  <s:table-cell>Quadro FX 570M/PCIe/SSE</s:table-cell>
  <s:table-cell>3.3.0 NVIDIA 302.17</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Mac OS X</s:table-cell>
  <s:table-cell>10.6.8</s:table-cell>
  <s:table-cell>x86_64</s:table-cell>
  <s:table-cell>Apple Inc.</s:table-cell>
  <s:table-cell>1.6.0_33</s:table-cell>
  <s:table-cell>Java HotSpot(TM) 64-Bit Server VM</s:table-cell>
  <s:table-cell>Apple Inc.</s:table-cell>
  <s:table-cell>20.8-b03-424</s:table-cell>
  <s:table-cell>ATI Technologies Inc.</s:table-cell>
  <s:table-cell>ATI Radeon HD 5670 OpenGL Engine</s:table-cell>
  <s:table-cell>2.1 ATI-1.6.36</s:table-cell>
</s:table-row>
<s:table-row>
  <s:table-cell>Windows XP</s:table-cell>
  <s:table-cell>5.1</s:table-cell>
  <s:table-cell>x86</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>1.7.0_05</s:table-cell>
  <s:table-cell>Java HotSpot(TM) Client VM</s:table-cell>
  <s:table-cell>Oracle Corporation</s:table-cell>
  <s:table-cell>23.1-b03</s:table-cell>
  <s:table-cell>ATI Technologies Inc.</s:table-cell>
  <s:table-cell>ATI Radeon HD 4800 Series</s:table-cell>
  <s:table-cell>3.3.10362 Compatibility Profile Context</s:table-cell>
</s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:paragraph>
        There are currently no known platform-specific issues.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term type="package">jcanephora</s:term>
        package are placed under the following license:
        <s:verbatim type="license"><![CDATA[Copyright Â© 2012 http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>jcanephora For OpenGL Programmers</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        As stated repeatedly, the <s:term type="package">jcanephora</s:term>
        package strives for increased static and run-time type safety. This
        does, however, mean that there are new abstractions to learn. This
        section of the documentation attempts to describe how to use the API
        for those already familiar with OpenGL. It presents small programs
        written in C and then shows the <s:term type="package">jcanephora</s:term>
        equivalent. For the sake of brevity, the C programs often use the
        obsolete fixed-function pipeline (otherwise each example would have
        to implement a lot of tedious matrix math and shading program
        management).
      </s:paragraph>
      <s:paragraph>
        Every <s:term type="package">jcanephora</s:term> program begins
        by creating or retrieving an implementation of the
        <s:link-external target="javadoc/com/io7m/jcanephora/GLInterface.html">GLInterface</s:link-external>
        or
        <s:link-external target="javadoc/com/io7m/jcanephora/GLInterfaceEmbedded.html">GLInterfaceEmbedded</s:link-external>
        type. At the time of writing, there are implementations based on
        <s:link-external target="http://lwjgl.org">LWJGL</s:link-external>
        and
        <s:link-external target="http://jogamp.org">JOGL</s:link-external>.
        Programs are insulated from the platform/implementation specific
        details of the OpenGL interface via the
        interface types - all operations occur via values of these types and
        client programs do not know anything about the underlying OpenGL
        implementation.
      </s:paragraph>
      <s:paragraph>
        The programmer is expected to know how to initialize either of
        <s:link-external target="http://lwjgl.org">LWJGL</s:link-external>
        or
        <s:link-external target="http://jogamp.org">JOGL</s:link-external>:
        the details are obviously outside of the scope of this
        documentation. Once initialized, the programmer can then use
        the constructors of any of the implementations of
        <s:term type="function">GLInterface</s:term>
        to get access to the <s:term type="package">jcanephora</s:term>
        APIs.
      </s:paragraph>
      <s:paragraph>
        Beyond the API exposed by <s:term type="function">GLInterface</s:term>,
        the <s:term type="package">jcanephora</s:term> package also provides
        various higher level abstractions that work through this interface,
        such as on-demand shader compilation with
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>,
        matrix manipulation with
        <s:link-external target="javadoc/com/io7m/jcanephora/ProjectionMatrix.html">ProjectionMatrix</s:link-external>,
        static and streaming textures, and more.
        See the <s:link-external target="javadoc/index.html">Javadoc</s:link-external>
        for details.
      </s:paragraph>
    </s:section>
    <s:section xml:id="com.io7m.jcanephora.tutorial_vbo">
      <s:section-title>Vertex Buffer Objects</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="vbo.c">vbo.c</s:link-external>]
        demonstrates the creation of vertex buffer and index buffer objects
        in plain OpenGL. It creates buffers and then draws them to the screen
        using the fixed-function OpenGL pipeline.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffers (C)</s:formal-item-title>
        <s:verbatim><xi:include href="../c/two-triangles.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> version demonstrates
        many of the package's convenience and safety features:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffers (Java)</s:formal-item-title>
        <s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleTriangle.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The program creates a new shading language program with the
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>
        interface. This interface gives easy and type-safe access to the uniform and
        attribute variables present in the program.
      </s:paragraph>
      <s:paragraph>
        The program allocates an
        <s:link-external target="javadoc/com/io7m/jcanephora/ArrayBuffer.html">array buffer</s:link-external>
        by creating an explicit description of the type of its elements with an
        <s:link-external target="javadoc/com/io7m/jcanephora/ArrayBufferDescriptor.html">ArrayBufferDescriptor</s:link-external>,
        and then allocating a given number of them.
      </s:paragraph>
      <s:paragraph>
        Using the type information given when the array buffer was created, the program
        obtains access to the elements of the array by using typed
        <s:link-external target="javadoc/com/io7m/jcanephora/Cursor.html">Cursors</s:link-external>.
        The cursors
        can only point to the specific attributes for which they are intended and refuse
        attempts to write to memory outside of the array data. The cursors also check the
        types of their intended attributes on creation and loudly refuse attempts to write
        to attributes that do not have the expected type. These features eliminate large
        classes of bugs usually associated with doing this kind of low-level memory
        management in C.
      </s:paragraph>
      <s:paragraph>
        The program allocates an
        <s:link-external target="javadoc/com/io7m/jcanephora/IndexBuffer.html">index buffer</s:link-external>
        by using the array buffer as a hint. This
        allows the <s:term type="package">jcanephora</s:term> package to pick the most
        efficient type for individual indices: If an array buffer has fewer than 256 vertices,
        for example, then there is no reason for the index buffer to use two or four-byte
        indices. This gives significant GPU memory savings whilst presenting a uniform
        interface to the programmer. It is also possible for the programmer to specify
        index buffer types directly, but that is not shown here.
      </s:paragraph>
      <s:paragraph>
        The program passes uniform values to the program over a simple and typed-check
        analogue to the <s:term type="function">glUniform*</s:term> interface. Attempting
        to pass a value of the wrong type is prevented at run-time.
      </s:paragraph>
      <s:paragraph>
        The program associates array buffer attributes with program attributes using
        a type-safe interface.
      </s:paragraph>
      <s:paragraph>
        In all cases, the API also tracks whether or not objects have been deleted
        (using a simple flag on the client side), and loudly signals when OpenGL resources
        that have been deleted are passed to various API functions. It would be an error,
        for example, to call the <s:term type="function">drawElements</s:term> function
        pictured when the array or index buffer had been deleted.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Textures</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="texture-simple.c">texture-simple.c</s:link-external>]
        demonstrates the creation and usage of textures. It generates a simple
        texture and displays it on a rectangle. The program uses the obsolete fixed-function
        pipeline for brevity, as previously mentioned.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (C)</s:formal-item-title>
        <s:verbatim><xi:include href="../c/texture-simple.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> version again demonstrates
        many of the package's convenience and safety features:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleTexturedQuad.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        In addition to the features demonstrated in the
        <s:link target="com.io7m.jcanephora.tutorial_vbo">previous example</s:link>, the
        program demonstrates a number of features specific to texturing.
      </s:paragraph>
      <s:paragraph>
        The program requests access to a list of the available texture units. This
        eliminates a class of bugs present in many programs that use
        <s:term type="function">glActiveTexture</s:term>: Most implementations support
        between 16-32 texture units, at the time of writing. OpenGL will raise an error
        if a program attempts to use more than the available number of units, but most
        programs also fail to check OpenGL error codes. The design of the
        <s:term type="package">jcanephora</s:term> API models texture units as concrete
        objects of type
        <s:link-external target="javadoc/com/io7m/jcanephora/TextureUnit.html">TextureUnit</s:link-external>
        and therefore programs cannot accidentally use more units than the implementation
        provides.
      </s:paragraph>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> hides the ridiculously complicated,
        type-unsafe and legacy-ridden <s:term type="function">glTexImage2D</s:term>,
        <s:term type="function">glTexSubImage2D</s:term>, and
        <s:term type="function">glTexParameter</s:term> interfaces
        and instead exposes a simple allocation function that takes values of various
        <s:term type="keyword">enum</s:term> types specifying the exact properties of the
        texture to be allocated. The texture type information is stored (client side) along
        with the details of the allocated texture, allowing type-safe access to texture data
        later on. Many of the combinations of parameters to the raw OpenGL functions
        are invalid, according to the OpenGL specifications. This API rejects the
        invalid combinations statically.
      </s:paragraph>
      <s:paragraph>
        The program updates the allocated texture by creating a new
        <s:link-external target="javadoc/com/io7m/jcanephora/Texture2DWritableData.html">client-side buffer of data</s:link-external>
        and then obtaining access to the data via a
        <s:link-external target="javadoc/com/io7m/jcanephora/SpatialCursor.html">typed cursor</s:link-external>
        interface. It is an error to try to obtain a cursor of the
        wrong type (such as requesting a cursor that points to
        four-component elements in a texture that only contains
        a luminance and alpha channel, for example). The cursor
        interface exposes a uniform interface with regards to color
        data and performs automatic conversion/color packing - the
        program works with simple linear RGBA color values and does
        not need to worry about converting/packing those values into
        the correct format for the texture.
      </s:paragraph>
      <s:paragraph>
        Finally, during rendering, the program binds the texture to a texture unit and
        uploads the name of the texture unit to the shading language program. Naturally,
        all of these operations have increased type safety (it's not possible to upload
        an arbitrary integer to a program that expects a
        <s:term type="type">sampler2D</s:term> type, for example).
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Shaders</s:section-title>
      <s:paragraph>
        The
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>
        interface is actually a higher-level abstraction to a low-level shading
        program interface.
      </s:paragraph>
      <s:paragraph>
        Diverging from the convention of showing the C program
        <s:footnote>Because the C version requires
          a large amount of support code; there's no "standard" way to
          write the same program.</s:footnote>
        and the
        <s:term type="package">jcanephora</s:term> equivalent, a complete example
        of loading a single triangle into a vertex buffer and drawing it with
        a GLSL shader, using the low-level shading language interface:
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Shaders (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleShaders.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The
        <s:link-external target="javadoc/com/io7m/jcanephora/Program.html">Program</s:link-external>
        interface is recommended as it implements a wide array of safety
        and convenience features:
        Empty programs are rejected <s:footnote>
          Some OpenGL implementations cannot handle empty shading language
          programs, therefore they are automatically rejected by
          <s:term type="package">jcanephora</s:term> to ensure code stays
          platform-independent.
        </s:footnote>, attempting to upload data to inactive programs is
        an error, shading programs are recompiled when their source
        code is updated, compilation errors are signalled immediately and
        do not damage internal state so that the program can continue running
        using the previous shading program executable.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Framebuffers</s:section-title>
      <s:paragraph>
        This example demonstrates the use of framebuffer objects to implement
        rendering to a texture. A framebuffer is allocated, a scene rendered
        to the texture by binding the framebuffer, and then a rectangle is
        rendered using the contents of the framebuffer texture. This results
        in a simple "animated" texture.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Framebuffers (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleFBO.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Again, the API enforces consistent semantics across implementations:
        Most OpenGL implementations cannot handle multiple depth/stencil
        attachments, so only one is currently permitted. Most current
        implementations cannot handle separate depth and stencil attachments,
        so the API only provides a
        <s:link-external target="javadoc/com/io7m/jcanephora/RenderbufferD24S8.html">single combined buffer</s:link-external>.
        "Completeness" checks are
        made automatically on storage attachment (upon allocation of the
        framebuffer), so it's not possible to draw to a framebuffer
        configuration that OpenGL considers invalid.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Everything Else</s:section-title>
      <s:paragraph>
        Modern OpenGL programming consists of little more than vertex buffer
        objects, shaders, and framebuffer objects, and the
        <s:term type="package">jcanephora</s:term> API reflects this.
      </s:paragraph>
      <s:paragraph>
        The rest of the <s:term type="package">jcanephora</s:term>
        API is concerned with adding type safety to the functions that
        work on the other parts of the OpenGL pipeline. The following
        table lists the <s:term type="package">jcanephora</s:term>
        equivalents of OpenGL features.
      </s:paragraph>
      <s:formal-item kind="feature_mapping" type="feature_mapping">
        <s:formal-item-title>Features</s:formal-item-title>
        <s:table>
          <s:table-summary>OpenGL/jcanephora feature mapping</s:table-summary>
          <s:table-head>
            <s:table-column-name>OpenGL</s:table-column-name>
            <s:table-column-name>jcanephora</s:table-column-name>
          </s:table-head>
          <s:table-body>
            <s:table-row>
              <s:table-cell><s:term type="function">glBlendFunc</s:term></s:table-cell>
              <s:table-cell>
                <s:link-external target="javadoc/com/io7m/jcanephora/GLBlending.html">GLBlending</s:link-external>,
                <s:link-external target="javadoc/com/io7m/jcanephora/GLBlendingEmbedded.html">GLBlendingEmbedded</s:link-external>
              </s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Vertex buffer objects</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLArrayBuffers.html">GLArrayBuffers</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Vertex buffer objects (glMapBuffer)</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLArrayBuffersMapped.html">GLArrayBuffersMapped</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glClear</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLColorBuffer.html">GLColorBuffer</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glCullFace</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLCull.html">GLCull</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glDepthFunc</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLDepthBuffer.html">GLDepthBuffer</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glDrawElements</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLDraw.html">GLDraw</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glGetError</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLMeta.html">GLMeta</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Index buffer objects</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLIndexBuffers.html">GLIndexBuffers</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell>Index buffer objects (glMapBuffer)</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLIndexBuffersMapped.html">GLIndexBuffersMapped</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glLogicOp</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLLogic.html">GLLogic</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glPolygonMode</s:term>, etc</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLPolygonModes.html">GLPolygonModes</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glLineWidth</s:term>, etc</s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLRasterization.html">GLRasterization</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glScissor</s:term>, <s:term type="function">glScissor</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLScissor.html">GLScissor</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glStencil</s:term>, <s:term type="function">glStencil</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLStencilBuffer.html">GLStencilBuffer</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glTexImage2D</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLTextures2DStatic.html">GLTextures2DStatic</s:link-external></s:table-cell>
            </s:table-row>
            <s:table-row>
              <s:table-cell><s:term type="function">glViewport</s:term></s:table-cell>
              <s:table-cell><s:link-external target="javadoc/com/io7m/jcanephora/GLViewport.html">GLViewport</s:link-external></s:table-cell>
            </s:table-row>
          </s:table-body>
        </s:table>
      </s:formal-item>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external target="javadoc">Javadoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>

</s:document>
