<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright Â© 2012 http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://www.io7m.com/schemas/structural/0.1.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>io7m-jcanephora 1.0.0 Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />
    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term>
          package implements a set of abstractions over
          <s:link-external target="http://opengl.org">OpenGL</s:link-external>
          with the intention of providing an API that enforces program
          correctness statically. The OpenGL API is extremely error prone, but
          thankfully most of the problems can be alleviated with the simple
          application of static types.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Correctness</s:subsection-title>
        <s:paragraph>
          Most functions in OpenGL return integers (type <s:term type="type">int</s:term>).
          The <s:term type="function">glCreateShader()</s:term> function, for example,
          returns an <s:term type="type">int</s:term> regardless of whether the function
          is creating a fragment shader or a vertex shader. Obviously, returning a different
          type depending on whether a fragment shader or a vertex shader would require
          a dependent type system. As Java clearly does not have dependent types, the
          <s:term type="package">jcanephora</s:term> package
          provides a <s:term type="function">compileVertexShader()</s:term> function that
          returns a value of type <s:term type="type">VertexShader</s:term> and a
          <s:term type="function">compileFragmentShader()</s:term> function that returns
          a value of type <s:term type="type">FragmentShader</s:term>, eliminating any
          chance of confusing the two at compile-time. The package takes a similar
          approach to static safety throughout.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Convenience</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package also provides
          on-demand (re)compilation of GLSL shader programs via a simple
          <s:term type="type">Program</s:term> API. The package is able to load
          programs from inside archives via
          <s:link-external target="http://io7m.com/software/jvvfs">jvvfs</s:link-external>.
          The <s:term type="type">Program</s:term> API also implements a simple abstraction
          over shading program parameters (attributes, uniforms) that makes it possible
          to query the names and types of parameters at run-time.
        </s:paragraph>
        <s:paragraph>
          The package also provides functions to produce orthographic and perspective
          projection matrices, and an implementation of the ubiquitous
          <s:term type="function">lookAt()</s:term>
          function for producing a view matrix that looks at a given point in space from
          a given location.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Simplicity</s:subsection-title>
        <s:paragraph>
          The <s:term type="package">jcanephora</s:term> package attempts to
          provide abstractions that are as minimal as possible. It should be
          possible for any experienced OpenGL programmer to use the package
          without having to learn new concepts or fight a complicated class
          hierarchy. The idea is to provide static type safety in as simple
          a manner as possible.
        </s:paragraph>
      </s:subsection>
    </s:section>
    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Installation Requirements</s:subsection-title>
        <s:paragraph>
          Iff compiling from source, the following jar files and directories
          must be placed in the directory <s:term type="file">ext</s:term> in
          the project root:
        </s:paragraph>
        <s:formal-item kind="dependency_table" type="dependencies">
          <s:formal-item-title>Compile-time dependencies</s:formal-item-title>
          <s:table>
            <s:table-summary>Compile-time dependencies</s:table-summary>
            <s:table-head>
              <s:table-column-name>Jar</s:table-column-name>
              <s:table-column-name>Source</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:term type="file">lwjgl-2.8.3</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://lwjgl.org">lwjgl</s:link-external></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="file">annotations.jar</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://findbugs.sourceforge.net">findbugs</s:link-external></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="file">jsr305.jar</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://findbugs.sourceforge.net">findbugs</s:link-external></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="file">io7m-jvvfs-0.3.1.jar</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://io7m.com/software/jvvfs/index.xhtml">jvvfs</s:link-external></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="file">io7m-jaux-0.5.0.jar</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://io7m.com/software/jaux/index.xhtml">jaux</s:link-external></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="file">io7m-jlog-0.2.0.jar</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://io7m.com/software/jlog/index.xhtml">jlog</s:link-external></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="file">io7m-jtensors-0.6.0.jar</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://io7m.com/software/jtensors/index.xhtml">jtensors</s:link-external></s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:term type="file">junit-4.10.jar</s:term></s:table-cell>
                <s:table-cell><s:link-external target="http://junit.org">junit</s:link-external></s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          The <s:term type="file">lwjgl-2.8.3</s:term> directory is obtained by unpacking
          <s:term type="file">lwjgl-2.8.3.zip</s:term> from the official site into the
          <s:term type="file">ext</s:term> directory.
        </s:paragraph>
        <s:paragraph>
          The project can then be compiled using
          <s:link-external target="http://ant.apache.org">Ant</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim type="example"><![CDATA[$ ant]]></s:verbatim>     
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Installation</s:subsection-title>
        <s:paragraph>
          Include <s:term type="file">io7m-jcanephora-1.0.0.jar</s:term>
          in your projects. The build process also produces a "source" jar
          file, <s:term type="file">io7m-jcanephora-source-1.0.0.jar</s:term>,
          that can be used for debugging in any IDE. The jar files do not
          contain any of the dependencies of the project, so these should
          be included separately.
        </s:paragraph>
      </s:subsection>
    </s:section>
    <s:section>
      <s:section-title>Supported Systems</s:section-title>
      <s:paragraph>
        The software is known to pass 100% of the included unit tests on the
        following platforms:
      </s:paragraph>
        <s:formal-item kind="platform_table" type="platforms">
          <s:formal-item-title>Supported systems</s:formal-item-title>
          <s:table>
            <s:table-summary>Supported systems</s:table-summary>
            <s:table-head>
              <s:table-column-name>OS</s:table-column-name>
              <s:table-column-name>OS-Version</s:table-column-name>
              <s:table-column-name>OS-Arch</s:table-column-name>
              <s:table-column-name>JDK-Vendor</s:table-column-name>
              <s:table-column-name>JDK-Version</s:table-column-name>
              <s:table-column-name>VM</s:table-column-name>
              <s:table-column-name>VM-Version</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell>Linux</s:table-cell>
                <s:table-cell>3.2.2-1-ARCH</s:table-cell>
                <s:table-cell>x86_64</s:table-cell>
                <s:table-cell>Sun Microsystems Inc.</s:table-cell>
                <s:table-cell>1.6.0_22</s:table-cell>
                <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
                <s:table-cell>19.0-b09</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell>Linux</s:table-cell>
                <s:table-cell>3.2.9-1-ARCH</s:table-cell>
                <s:table-cell>x86_64</s:table-cell>
                <s:table-cell>Sun Microsystems Inc.</s:table-cell>
                <s:table-cell>1.6.0_24</s:table-cell>
                <s:table-cell>OpenJDK 64-Bit Server VM</s:table-cell>
                <s:table-cell>20.0-b12</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell>Windows XP</s:table-cell>
                <s:table-cell>5.1</s:table-cell>
                <s:table-cell>x86</s:table-cell>
                <s:table-cell>Oracle Corporation</s:table-cell>
                <s:table-cell>1.7.0_02</s:table-cell>
                <s:table-cell>Java Hotspot(TM) Client VM</s:table-cell>
                <s:table-cell>22.0-b10</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell>Mac OS X</s:table-cell>
                <s:table-cell>10.6.8</s:table-cell>
                <s:table-cell>x86_64</s:table-cell>
                <s:table-cell>Apple Inc.</s:table-cell>
                <s:table-cell>1.6.0_29</s:table-cell>
                <s:table-cell>Java Hotspot(TM) 64-Bit Server VM</s:table-cell>
                <s:table-cell>20.4-b02-402</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell>SunOS</s:table-cell>
                <s:table-cell>5.11</s:table-cell>
                <s:table-cell>x86</s:table-cell>
                <s:table-cell>Sun Microsystems Inc.</s:table-cell>
                <s:table-cell>1.6.0_21</s:table-cell>
                <s:table-cell>Java Hotspot(TM) Client VM</s:table-cell>
                <s:table-cell>17.0-b16</s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
    </s:section>
    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:paragraph>
        There are currently no known platform-specific issues.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term type="package">jcanephora</s:term>
        package are placed under the following license:
        <s:verbatim type="license"><![CDATA[Copyright Â© 2012 http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>jcanephora For C Programmers</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        As stated repeatedly, the <s:term type="package">jcanephora</s:term>
        package strives for increased static and run-time type safety. This
        does, however, mean that there are new abstractions to learn. This
        section of the documentation attempts to describe how to use the API
        for those already familiar with OpenGL. It presents small programs
        written in C and then shows the <s:term type="package">jcanephora</s:term>
        equivalent.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Vertex Buffer Objects</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="vbo.c">vbo.c</s:link-external>]
        demonstrates the creation of vertex buffer and index buffer objects
        in plain OpenGL. It creates buffers but does not draw anything to
        the screen.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffer initialization (C)</s:formal-item-title>
        <s:verbatim><![CDATA[
#define GL_GLEXT_PROTOTYPES 1

#include <assert.h>
#include <err.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <GL/glut.h>
#include <GL/glext.h>

typedef float vector3[3];

typedef struct
{
  vector3 position;
  vector3 color;
} vertex;

static GLuint buffer;
static GLuint triangles[2];

static void
init_data()
{
  unsigned int elements = 4;
  unsigned int size = elements * sizeof(vertex);

  glGenBuffers(1, &buffer);
  glBindBuffer(GL_ARRAY_BUFFER, buffer);
  glBufferData(GL_ARRAY_BUFFER, size, NULL, GL_STREAM_DRAW);
  assert (glGetError() == GL_NO_ERROR);

  {
    vertex *map = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
    assert (map != NULL);

    map[0].position[0] = 0.0f;
    map[0].position[1] = 1.0f;
    map[0].position[2] = 0.0f;
    map[0].color[0] = 1.0f;
    map[0].color[1] = 0.0f;
    map[0].color[2] = 0.0f;

    map[1].position[0] = 0.0f;
    map[1].position[1] = 0.0f;
    map[1].position[2] = 0.0f;
    map[1].color[0] = 1.0f;
    map[1].color[1] = 1.0f;
    map[1].color[2] = 0.0f;

    map[2].position[0] = 1.0f;
    map[2].position[1] = 0.0f;
    map[2].position[2] = 0.0f;
    map[2].color[0] = 0.0f;
    map[2].color[1] = 1.0f;
    map[2].color[2] = 0.0f;

    map[3].position[0] = 1.0f;
    map[3].position[1] = 1.0f;
    map[3].position[2] = 0.0f;
    map[3].color[0] = 0.0f;
    map[3].color[1] = 1.0f;
    map[3].color[2] = 1.0f;
  }

  glUnmapBuffer(GL_ARRAY_BUFFER);
  assert (glGetError() == GL_NO_ERROR);

  glGenBuffers(2, triangles);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, triangles[0]);
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, 3, NULL, GL_STREAM_DRAW);

  {
    unsigned char *map = glMapBuffer(GL_ELEMENT_ARRAY_BUFFER, GL_WRITE_ONLY);
    assert (map != NULL);
    map[0] = 0;
    map[1] = 1;
    map[2] = 2;
  }
  glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, triangles[1]);
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, 3, NULL, GL_STREAM_DRAW);

  {
    unsigned char *map = glMapBuffer(GL_ELEMENT_ARRAY_BUFFER, GL_WRITE_ONLY);
    assert (map != NULL);
    map[0] = 0;
    map[1] = 2;
    map[2] = 3;
  }
  glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);

  assert(glGetError() == GL_NO_ERROR);
}

static void
reshape(int width, int height)
{
  assert (width >= 0);
  assert (height >= 0);
}

static void
display(void)
{

}

int
main (int argc, char **argv)
{
  glutInit(&argc, argv);
  glutCreateWindow("VBO");
  init_data();
  glutReshapeFunc(reshape);
  glutDisplayFunc(display);
  glutIdleFunc(glutPostRedisplay);

  glutMainLoop();
  return 0;
}]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Where the <s:link-external target="vbo.c">C version</s:link-external>
        creates essentially untyped memory, the <s:term type="package">jcanephora</s:term>
        version requires programmers to use explicit type descriptors for
        buffers. In order to write to the map, the programmer has to obtain
        access via typed cursors. Intuitively, if the array buffer is thought
        of as an array of records of a given type, the cursors can only point
        to specific fields in the records as they seek through the array.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Vertex buffer initialization (Java)</s:formal-item-title>
        <s:verbatim><![CDATA[package com.io7m.jcanephora.examples.lwjgl30;

import java.util.Properties;

import org.lwjgl.LWJGLException;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;

import com.io7m.jaux.Constraints.ConstraintError;
import com.io7m.jcanephora.ArrayBuffer;
import com.io7m.jcanephora.ArrayBufferAttribute;
import com.io7m.jcanephora.ArrayBufferCursorWritable3f;
import com.io7m.jcanephora.ArrayBufferDescriptor;
import com.io7m.jcanephora.ArrayBufferWritableMap;
import com.io7m.jcanephora.GLException;
import com.io7m.jcanephora.GLInterface;
import com.io7m.jcanephora.GLInterfaceLWJGL30;
import com.io7m.jcanephora.GLScalarType;
import com.io7m.jcanephora.GLUnsignedType;
import com.io7m.jcanephora.IndexBuffer;
import com.io7m.jcanephora.IndexBufferWritableMap;
import com.io7m.jlog.Log;

public final class VBOExample
{
  @SuppressWarnings("unused") public static void main(
    final String args[])
    throws LWJGLException,
      ConstraintError,
      GLException
  {
    Display.setDisplayMode(new DisplayMode(640, 480));
    Display.setTitle("VBOExample");
    Display.create();

    final Log log = new Log(new Properties(), "com.io7m", "example");
    final GLInterface gl = new GLInterfaceLWJGL30(log);

    try {
      new VBOExample(gl);
    } finally {
      Display.destroy();
    }
  }

  final ArrayBuffer           buffer;
  final ArrayBufferDescriptor buffer_type;
  final IndexBuffer           triangles[];

  private VBOExample(
    final GLInterface gl)
    throws ConstraintError,
      GLException
  {
    /*
     * An array buffer is an array of records. First, create the description
     * of the record type by assigning and name and type to each of the
     * fields. Here, the two fields are "position" and "color" - both
     * three-element vectors of type 'float'.
     */

    final ArrayBufferAttribute as[] = new ArrayBufferAttribute[2];
    as[0] = new ArrayBufferAttribute("position", GLScalarType.TYPE_FLOAT, 3);
    as[1] = new ArrayBufferAttribute("color", GLScalarType.TYPE_FLOAT, 3);
    this.buffer_type = new ArrayBufferDescriptor(as);

    /*
     * Allocate an array buffer containing four elements of the above record
     * type.
     */

    this.buffer = gl.allocateArrayBuffer(4, this.buffer_type);
    {
      /*
       * Map the allocated buffer into the application's address space. Obtain
       * cursors to the "position" and "cursor" fields. Cursors automatically
       * seek through the buffer when writing values. The type of the cursor
       * is checked against the type of the target attribute, raising an
       * exception if the types do not match.
       */

      final ArrayBufferWritableMap map = gl.mapArrayBufferWrite(this.buffer);
      final ArrayBufferCursorWritable3f position =
        map.getCursor3f("position");
      final ArrayBufferCursorWritable3f color = map.getCursor3f("color");

      /*
       * Note that the two cursors are independent: writes to the attributes
       * could be interleaved without changing the semantics of the program.
       */

      position.put3f(0.0f, 1.0f, 0.0f);
      position.put3f(0.0f, 0.0f, 0.0f);
      position.put3f(0.0f, 1.0f, 0.0f);
      position.put3f(0.0f, 1.0f, 1.0f);
      color.put3f(1.0f, 0.0f, 0.0f);
      color.put3f(1.0f, 1.0f, 0.0f);
      color.put3f(0.0f, 1.0f, 0.0f);
      color.put3f(0.0f, 1.0f, 1.0f);

      /*
       * Check that all elements of the buffer have been written.
       */

      assert (position.hasNext() == false);
      assert (color.hasNext() == false);

      /*
       * Unmap the array buffer.
       */

      gl.unmapArrayBuffer(this.buffer);
    }

    /*
     * Create two index buffers, representing two triangles. The index buffer
     * interface automatically picks the smallest type possible for indices
     * (based on the number of elements in the passed array buffer). For
     * example, if an array buffer has less than 256 elements, the indices
     * will be single bytes.
     */

    this.triangles = new IndexBuffer[2];
    this.triangles[0] = gl.allocateIndexBuffer(this.buffer, 3);

    assert this.triangles[0].getType() == GLUnsignedType.TYPE_UNSIGNED_BYTE;
    assert this.triangles[1].getType() == GLUnsignedType.TYPE_UNSIGNED_BYTE;

    {
      final IndexBufferWritableMap map =
        gl.mapIndexBufferWrite(this.triangles[0]);

      /*
       * Insert vertex indices into the map.
       */

      map.put(0, 0);
      map.put(1, 1);
      map.put(2, 2);

      gl.unmapIndexBuffer(this.triangles[0]);
    }

    this.triangles[1] = gl.allocateIndexBuffer(this.buffer, 3);
    {
      final IndexBufferWritableMap map =
        gl.mapIndexBufferWrite(this.triangles[1]);

      map.put(0, 0);
      map.put(1, 2);
      map.put(2, 3);

      gl.unmapIndexBuffer(this.triangles[1]);
    }
  }
}]]></s:verbatim>
      </s:formal-item>
    </s:section>
    <s:section>
      <s:section-title>Textures</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="textures.c">textures.c</s:link-external>]
        demonstrates the creation of textures. It creates a texture and
        a pixel buffer to hold bitmap data.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (C)</s:formal-item-title>
        <s:verbatim><![CDATA[
#define GL_GLEXT_PROTOTYPES 1

#include <assert.h>
#include <err.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <GL/glut.h>
#include <GL/glext.h>

typedef struct {
  unsigned char r;
  unsigned char g;
  unsigned char b;
  unsigned char a;
} abgr_t;

static GLuint pixel_buffer;
static GLuint texture;
static const GLuint texture_size = 4 * 4 * sizeof(abgr_t);

static void
init_data()
{
  glGenBuffers(1, &pixel_buffer);
  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pixel_buffer);
  glBufferData(GL_PIXEL_UNPACK_BUFFER, texture_size, NULL, GL_STREAM_DRAW);
  assert(glGetError() == GL_NO_ERROR);

  {
    int x;
    int y;
    abgr_t *map = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
    assert (map != NULL);

    for (y = 0; y < 4; ++y) {
      double fy = y;
      for (x = 0; x < 4; ++x) {
        double fx = x;
        map->r = (unsigned char) (256.0 * (fx / 4.0));
        map->g = (unsigned char) (256.0 * (fy / 4.0));
        map->b = 0xff;
        map->a = 0xff;
        ++map;
      }
    }

    glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
    assert(glGetError() == GL_NO_ERROR);
  }

  glGenTextures(1, &texture);
  glBindTexture(GL_TEXTURE_2D, texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 4, 4, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
  assert(glGetError() == GL_NO_ERROR);

  glBindTexture(GL_TEXTURE_2D, 0);
  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
}

static void
reshape(int width, int height)
{
  assert (width >= 0);
  assert (height >= 0);
}

static void
display(void)
{

}

int
main (int argc, char **argv)
{
  glutInit(&argc, argv);
  glutCreateWindow("Textures");
  init_data();
  glutReshapeFunc(reshape);
  glutDisplayFunc(display);
  glutIdleFunc(glutPostRedisplay);

  glutMainLoop();
  return 0;
}
]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term type="package">jcanephora</s:term> version uses
        the <s:term type="package">Texture2DRGBA</s:term> API to create
        a blank texture backed by a pixel unpack buffer. The buffer is
        then mapped into the client address space and a typed cursor is
        obtained that points to each pixel in the buffer. The buffer is
        then unmapped and the texture is told to refresh itself from the
        pixel buffer. The texture API, as a side effect, provides trivial
        "streaming textures".
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Textures (Java)</s:formal-item-title>
        <s:verbatim><![CDATA[
package com.io7m.jcanephora.examples.lwjgl30;

import java.util.Properties;

import javax.annotation.Nonnull;

import org.lwjgl.opengl.Display;

import com.io7m.jaux.Constraints.ConstraintError;
import com.io7m.jcanephora.GLException;
import com.io7m.jcanephora.GLInterface;
import com.io7m.jcanephora.GLInterfaceLWJGL30;
import com.io7m.jcanephora.LWJGL30;
import com.io7m.jcanephora.PixelUnpackBufferCursorWritable4b;
import com.io7m.jcanephora.PixelUnpackBufferWritableMap;
import com.io7m.jcanephora.Texture2DRGBA;
import com.io7m.jcanephora.TextureFilter;
import com.io7m.jcanephora.TextureWrap;
import com.io7m.jlog.Log;

public final class TextureExampleSimple
{
  private static int SCREEN_WIDTH   = 640;
  private static int SCREEN_HEIGHT  = 480;
  private static int TEXTURE_WIDTH  = 4;
  private static int TEXTURE_HEIGHT = 4;

  @SuppressWarnings("unused") public static void main(
    final String args[])
    throws ConstraintError,
      Error,
      GLException
  {
    LWJGL30.createDisplay(
      "TextureExample",
      TextureExampleSimple.SCREEN_WIDTH,
      TextureExampleSimple.SCREEN_HEIGHT);

    final Log log = new Log(new Properties(), "com.io7m", "example");
    final GLInterface gl = new GLInterfaceLWJGL30(log);

    try {
      new TextureExampleSimple(gl);
    } finally {
      Display.destroy();
    }
  }

  private final @Nonnull GLInterface gl;
  private final Texture2DRGBA        texture;

  public TextureExampleSimple(
    final GLInterface gl)
    throws ConstraintError,
      GLException
  {
    this.gl = gl;

    /*
     * Allocate an RGBA texture with the given filter and map modes.
     */

    this.texture =
      this.gl.allocateTextureRGBA(
        "Texture",
        TextureExampleSimple.TEXTURE_WIDTH,
        TextureExampleSimple.TEXTURE_HEIGHT,
        TextureWrap.TEXTURE_WRAP_REPEAT,
        TextureWrap.TEXTURE_WRAP_REPEAT,
        TextureFilter.TEXTURE_FILTER_NEAREST,
        TextureFilter.TEXTURE_FILTER_NEAREST);

    /*
     * Textures are automatically backed by a pixel unpack buffer. This buffer
     * is mapped into the program's address space in order to be populated
     * with bitmap data. A cursor is obtained in order to safely insert four
     * values of type 'byte' for each element.
     */

    {
      final PixelUnpackBufferWritableMap map =
        this.gl.mapPixelUnpackBufferWrite(this.texture.getBuffer());
      final PixelUnpackBufferCursorWritable4b c = map.getCursor4b();

      for (int y = 0; y < 4; ++y) {
        final double fy = y;
        for (int x = 0; x < 4; ++x) {
          final double fx = x;
          c.put4b(
            (byte) (256.0 * (fx / 4.0)),
            (byte) (256.0 * (fy / 4.0)),
            (byte) 0xff,
            (byte) 0xff);
        }
      }

      assert c.hasNext() == false;
      this.gl.unmapPixelUnpackBuffer(this.texture.getBuffer());
    }

    /*
     * Copy data from the pixel buffer into the texture.
     */

    this.gl.updateTexture2DRGBA(this.texture);
  }
}
]]></s:verbatim>
      </s:formal-item>
    </s:section>
    <s:section>
      <s:section-title>Texture Usage</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external target="texture-usage.c">texture-usage.c</s:link-external>]
        demonstrates the creation and usage of textures. It loads a TIFF
        image using <s:link-external target="http://libtiff.org">libTIFF</s:link-external>,
        binds it to the first texture unit, and displays it on a textured
        quad.
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>Texture Usage (C)</s:formal-item-title>
        <s:verbatim><![CDATA[
#define GL_GLEXT_PROTOTYPES 1

#include <assert.h>
#include <err.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include <GL/glut.h>
#include <GL/glext.h>
#include <tiffio.h>

static GLuint pixel_buffer;
static GLuint texture;

static void
init_data()
{
  uint32 width;
  uint32 height;
  uint32 texture_size;

  TIFF *tiff = TIFFOpen("32.tiff", "r");
  assert (tiff != NULL);

  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);
  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);
  texture_size = width * height * 4;

  glGenBuffers(1, &pixel_buffer);
  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pixel_buffer);
  glBufferData(GL_PIXEL_UNPACK_BUFFER, texture_size, NULL, GL_STREAM_DRAW);
  assert(glGetError() == GL_NO_ERROR);

  {
    unsigned char *map = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
    int r = TIFFReadRGBAImage(tiff, width, height, (uint32 *) map, 0);
    assert (r != 0);
    glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
    TIFFClose(tiff);
  }

  glGenTextures(1, &texture);
  glBindTexture(GL_TEXTURE_2D, texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
  assert(glGetError() == GL_NO_ERROR);

  glBindTexture(GL_TEXTURE_2D, 0);
  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
}

static void
reshape(int width, int height)
{
  assert (width > 0);
  assert (height > 0);
}

static void
display(void)
{
  glClearColor(0.2, 0.2, 0.2, 1.0);
  glClear(GL_COLOR_BUFFER_BIT);

  glEnable(GL_TEXTURE_2D);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, texture);

  glBegin(GL_QUADS);
  {
    glTexCoord2d(0.0, 1.0);
    glVertex3d(-0.5, 0.5, 0.0);
    glTexCoord2d(0.0, 0.0);
    glVertex3d(-0.5, -0.5,  0.0);
    glTexCoord2d(1.0, 0.0);
    glVertex3d(0.5, -0.5, 0.0);
    glTexCoord2d(1.0, 1.0);
    glVertex3d(0.5, 0.5, 0.0);
  }
  glEnd();

  glutSwapBuffers();
}

int
main (int argc, char **argv)
{
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE);  
  glutInitWindowSize(256, 256);
  glutCreateWindow("Textures");

  init_data();

  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutIdleFunc(glutPostRedisplay);

  glutMainLoop();
  return 0;
}
]]></s:verbatim>
      </s:formal-item>
      <s:formal-item kind="example">
        <s:formal-item-title>Texture Usage (Java)</s:formal-item-title>
        <s:verbatim><![CDATA[

]]></s:verbatim>
      </s:formal-item>
    </s:section>
    <s:section>
      <s:section-title>DrawElements</s:section-title>
      <s:formal-item kind="example">
        <s:formal-item-title>DrawElements (C)</s:formal-item-title>
        <s:verbatim><![CDATA[

]]></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        Where the <s:link-external target="draw.c">C version</s:link-external>...
      </s:paragraph>
      <s:formal-item kind="example">
        <s:formal-item-title>DrawElements (Java)</s:formal-item-title>
        <s:verbatim><![CDATA[

]]></s:verbatim>
      </s:formal-item>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external target="javadoc">Javadoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>

</s:document>
