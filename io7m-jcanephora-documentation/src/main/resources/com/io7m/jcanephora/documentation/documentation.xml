<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright © 2013 <code@io7m.com> http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:document
  xmlns:s="http://schemas.io7m.com/structural/2.0.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:document-title>${project.parent.name} ${project.version} Documentation</s:document-title>
  <s:document-style>documentation.css</s:document-style>
  <s:document-contents/>

  <s:part>
    <s:part-title>Package Information</s:part-title>
    <s:part-contents />
    <s:section>
      <s:section-title>Orientation</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">jcanephora</s:term>
          package implements a set of abstractions over
          <s:link-external s:target="http://opengl.org">OpenGL</s:link-external>
          with the intention of providing an API that enforces program
          correctness statically. The OpenGL API is extremely error prone, but
          thankfully most of the problems can be alleviated with the simple
          application of static types. Where the Java type system is too weak
          to give static guarantees, dynamic checks are used to prevent silent
          failure.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Correctness</s:subsection-title>
        <s:paragraph>
          Most functions in OpenGL return integers (type <s:term s:type="type">int</s:term>).
          The <s:term s:type="function">glCreateShader()</s:term> function, for example,
          returns an <s:term s:type="type">int</s:term> regardless of whether the function
          is creating a fragment shader or a vertex shader. Obviously, returning a different
          type depending on whether a fragment shader or a vertex shader was requested
          would require a dependent type system. As Java clearly does not have dependent types, the
          <s:term s:type="package">jcanephora</s:term> package
          provides a <s:term s:type="function">vertexShaderCompile()</s:term> function that
          returns a value of type <s:term s:type="type">VertexShaderType</s:term> and a
          <s:term s:type="function">fragmentShaderCompile()</s:term> function that returns
          a value of type <s:term s:type="type">FragmentShaderType</s:term>, eliminating any
          chance of confusing the two at compile-time. The package takes a similar
          approach to static safety throughout.
        </s:paragraph>
        <s:paragraph>
          All implementations of the <s:term s:type="package">jcanephora</s:term> API are
          run through a large battery of tests to ensure consistent semantics.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Simplicity</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">jcanephora</s:term> package attempts to
          provide abstractions that are as minimal as possible. It should be
          possible for any experienced OpenGL programmer to use the package
          without having to learn new concepts or fight a complicated class
          hierarchy. The idea is to provide static type safety in as simple
          a manner as possible.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Compatibility</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">jcanephora</s:term> exposes interfaces
          that allows developers to target the various common subsets of
          OpenGL ES2, OpenGL ES3, OpenGL 2.1, and OpenGL 3.*,
          with incompatibilities between the two indicated
          <s:term s:type="emphasis">statically</s:term>. This means that a
          developer using <s:term s:type="package">jcanephora</s:term> gets
          strong guarantees that their program will work on as many OpenGL
          implementations as possible, with implementation-specific parts
          clearly indicated by the type system.
        </s:paragraph>
        <s:formal-item s:kind="images">
          <s:formal-item-title>OpenGL Versioning</s:formal-item-title>
          <s:image s:source="images/venn.png">OpenGL versioning</s:image>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Performance</s:subsection-title>
        <s:paragraph>
          OpenGL programs often have high performance requirements.
          The <s:term s:type="package">jcanephora</s:term> API abstractions
          attempt to be as cheap as possible. Operations that allocate memory or perform
          potentially expensive operations are clearly marked. Emphasis is placed on
          writing code paths that generate little in the way of garbage to be collected,
          reducing GC pressure and improving realtime performance. Many potentially expensive
          queries (such as the available number of texture units) are requested eagerly and
          cached, in order to reduce the number of OpenGL calls required at "render time".
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Requirements</s:section-title>
      <s:paragraph>
        The Maven POM files are the canonical source for the project's
        dependencies:
      </s:paragraph>
      <s:formal-item s:kind="listings">
        <s:formal-item-title>POM files</s:formal-item-title>
        <s:list-unordered>
<s:list-item><s:link-external s:target="./io7m-jcanephora-core-1.0.0.pom">io7m-jcanephora-core-1.0.0.pom</s:link-external></s:list-item>
<s:list-item><s:link-external s:target="./io7m-jcanephora-batchexec-1.0.0.pom">io7m-jcanephora-batchexec-1.0.0.pom</s:link-external></s:list-item>
<s:list-item><s:link-external s:target="./io7m-jcanephora-examples-1.0.0.pom">io7m-jcanephora-examples-1.0.0.pom</s:link-external></s:list-item>
<s:list-item><s:link-external s:target="./io7m-jcanephora-examples-jogl-1.0.0.pom">io7m-jcanephora-examples-jogl-1.0.0.pom</s:link-external></s:list-item>
<s:list-item><s:link-external s:target="./io7m-jcanephora-jogl-1.0.0.pom">io7m-jcanephora-jogl-1.0.0.pom</s:link-external></s:list-item>
<s:list-item><s:link-external s:target="./io7m-jcanephora-tests-1.0.0.pom">io7m-jcanephora-tests-1.0.0.pom</s:link-external></s:list-item>
<s:list-item><s:link-external s:target="./io7m-jcanephora-tests-jogl-1.0.0.pom">io7m-jcanephora-tests-jogl-1.0.0.pom</s:link-external></s:list-item>
<s:list-item><s:link-external s:target="./io7m-jcanephora-texload-imageio-1.0.0.pom">io7m-jcanephora-texload-imageio-1.0.0.pom</s:link-external></s:list-item>
        </s:list-unordered>
      </s:formal-item>
      <s:paragraph>
        Beyond the dependencies given in the POM files, the
        <s:term s:type="package">jcanephora</s:term> package requires at least
        one of the following:
      </s:paragraph>
      <s:formal-item s:kind="listings">
        <s:formal-item-title>OpenGL Requirements</s:formal-item-title>
        <s:list-unordered>
          <s:list-item>A GPU supporting OpenGL >= 3.0</s:list-item>
          <s:list-item>A GPU supporting OpenGL ES2</s:list-item>
          <s:list-item>A GPU supporting OpenGL ES3</s:list-item>
          <s:list-item>
            A GPU supporting OpenGL 2.1, with extensions
            <s:term s:type="constant">ARB_framebuffer_object</s:term>,
            <s:term s:type="constant">EXT_framebuffer_object</s:term>,
            <s:term s:type="constant">EXT_framebuffer_multisample</s:term>,
            <s:term s:type="constant">EXT_framebuffer_blit</s:term> and
            <s:term s:type="constant">GL_EXT_packed_depth_stencil</s:term>.
          </s:list-item>
        </s:list-unordered>
      </s:formal-item>
    </s:section>

    <s:section>
      <s:section-title>Installation</s:section-title>
      <s:subsection>
        <s:subsection-title>Source compilation</s:subsection-title>
        <s:paragraph>
          The project can be compiled and installed with
          <s:link-external s:target="http://maven.apache.org">Maven</s:link-external>:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim s:type="example"><![CDATA[$ mvn -C clean install]]></s:verbatim>
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Maven</s:subsection-title>
        <s:paragraph>
          Regular releases are made to the
          <s:link-external s:target="http://search.maven.org/#search%7Cga%7C1%7Cjcanephora">Central Repository</s:link-external>,
          so it's possible to use the <s:term s:type="package">jcanephora</s:term>
          package in your projects by simply adding some dependencies to
          your Maven project.
        </s:paragraph>
        
        <s:paragraph>
          The package is split into multiple sub-packages. The
          <s:term s:type="package">jcanephora-core</s:term> package provides
          the types, interfaces, and implementations comprising the core of
          <s:term s:type="package">jcanephora</s:term>. This package is
          required to use <s:term s:type="package">jcanephora</s:term>.
        </s:paragraph>
        <s:paragraph>
          <s:verbatim s:type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jcanephora</groupId>
  <artifactId>io7m-jcanephora-core</artifactId>
  <version>1.0.0</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
        
        <s:paragraph>
          To use the <s:link-external s:target="http://jogamp.org">JOGL</s:link-external>
          backend for <s:term s:type="package">jcanephora</s:term>, include the
          <s:term s:type="package">jcanephora-jogl</s:term> package:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim s:type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jcanephora</groupId>
  <artifactId>io7m-jcanephora-jogl</artifactId>
  <version>1.0.0</version>
</dependency>]]></s:verbatim>
        </s:paragraph>

        <s:paragraph>
          To use the optional 
          <s:link-external s:target="apidocs/com/io7m/jcanephora/TextureLoaderImageIO.html">ImageIO</s:link-external>
          implementation of the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/TextureLoader.html">TextureLoader</s:link-external>
          interface, include the
          <s:term s:type="package">jcanephora-texload-imageio</s:term> package:
        </s:paragraph>
        <s:paragraph>
          <s:verbatim s:type="example"><![CDATA[<dependency>
  <groupId>com.io7m.jcanephora</groupId>
  <artifactId>io7m-jcanephora-texload-imageio</artifactId>
  <version>1.0.0</version>
</dependency>]]></s:verbatim>
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section>
      <s:section-title>Platform Specific Issues</s:section-title>
      <s:paragraph>
        There are currently no known platform-specific issues.
      </s:paragraph>
    </s:section>

    <s:section>
      <s:section-title>License</s:section-title>
      <s:paragraph>
        All files distributed with the <s:term s:type="package">jcanephora</s:term>
        package are placed under the following license:
        <s:verbatim s:type="license"><![CDATA[Copyright © 2014 <code@io7m.com> http://io7m.com

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.]]>
        </s:verbatim>
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>Design/Rationale</s:part-title>
    <s:part-contents/>

    <s:section xml:id="rationale.problems">
      <s:section-title>Problems with OpenGL</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">jcanephora</s:term> package takes the
          general view that OpenGL as an API is a ridiculously error-prone
          and poorly defined mess
          <s:footnote>
            Whilst, annoyingly, being the only viable cross-platform and
            vendor neutral graphics API available.
          </s:footnote>. The package attempts to address most if not all of
          the problems listed in this section. 
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.problems.versioning">
        <s:subsection-title>Versioning</s:subsection-title>
        <s:paragraph>
          Severely mismanaged by multiple committees since its inception,
          OpenGL has an excruciating approach to backwards compability. It 
          is only in relatively
          recent versions of OpenGL (3.0 and beyond) that features have
          actually been removed from the API. Where this has happened, the
          removals have occurred in the worst way possible: Previously valid
          function calls simply become runtime errors.
        </s:paragraph>
        <s:paragraph>
          The version numbering system for OpenGL is also apparently
          meaningless when it comes to compatibility. Developers cannot
          safely give version constraints for their programs such as
          "this program works on version <s:term s:type="variable">p</s:term>,
          where <s:term s:type="expression">4.0 &lt;= p &lt; 5.0</s:term>"
          as is standard practice for developers using some form of
          <s:link-external s:target="http://semver.org">semantic
          versioning</s:link-external>. OpenGL features may be deprecated
          without warning and deployed programs, without modification by
          developers, will simply stop working on newer OpenGL contexts
          <s:footnote>
            As an aside, this essentially results in an impossible situation
            for developers wanting to write programs that run on as many
            implementations as possible: They cannot ask for a
            <s:term s:type="emphasis">specific</s:term> version
            of OpenGL, as it may not be available. They cannot ask for any
            version <s:term s:type="emphasis">older</s:term> than a specific
            version, as it may not be available. They cannot ask for any
            version <s:term s:type="emphasis">equal to or newer</s:term> than
            a specific version, because they cannot know when the OpenGL 
            committees will deprecate or remove features. What do most programs
            do? Open a context and simply hope.
          </s:footnote>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.problems.availability">
        <s:subsection-title>Availability</s:subsection-title>
        <s:paragraph>
          At the time of writing, there is still a chaotic range of versions
          of OpenGL deployed. On hardware older than about five years, the
          most commonly available version of OpenGL is 2.1. Those using
          more recent hardware, but using an older version of Mac OS X, only
          have access to 2.1. On mobile devices, the most commonly available
          version of OpenGL ES is ES2. Different drivers on the same operating
          systems result in differing degrees of support. The open-source
          <s:link-external s:target="http://www.x.org/wiki/radeon">radeon</s:link-external>
          driver supports up to OpenGL 3.1 on Linux. The same driver on the same
          hardware on one of the BSD operating systems will typically only
          expose the fixed-function pipeline (FreeBSD up until recently,
          would only expose OpenGL 1.3!). The same hardware, on the same
          operating system, but using the proprietary Catalyst™ driver from AMD,
          will typically support the latest available version of the OpenGL
          4 branch (4.3, currently). Intel GPUs on Linux platforms expose
          OpenGL ES2, OpenGL ES3, OpenGL 3.0, and OpenGL 3.1.
        </s:paragraph>
        <s:paragraph>
          Developers wanting their programs to work on as many platforms as
          possible have to take extreme care to identify the portable subset
          (unless they effectively want to write the same program once for
          each version of the API
          <s:footnote>
            Not exactly ideal for an API that insists that it has excellent
            backwards compatibility.
          </s:footnote> or write insane and impossible-to-test branching
          version-specific code).
        </s:paragraph>
        <s:paragraph>
          In addition to the chaos above, drivers regularly deviate from the
          published OpenGL specifications. A developer has to know by
          <s:term s:type="emphasis">trial and error</s:term>, which features
          <s:term s:type="emphasis">do not work on any available implementations</s:term>.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.problems.embedded">
        <s:subsection-title>Embedded subsets</s:subsection-title>
        <s:paragraph>
          Apparently exhausted with the complete incompetence on the part
          of the committees managing the OpenGL API, vendors began work
          on a specification for an "embedded" "subset" of the API, containing
          none of the entirely irrelevant and useless features that had been
          stubbornly carried around for years
          <s:footnote>
            The committee in charge of the OpenGL API refused to admit
            the existence of programmable graphics hardware, instead choosing
            to try to emulate features of this hardware by endlessly extending
            the fixed-function pipeline.
          </s:footnote> and represented a huge implementation burden for
          vendors without any benefit. Unfortunately, the resulting 
          API - OpenGL ES - isn't actually a subset. There are numerous
          incompatibilities, meaning that while OpenGL 3.0 and ES2 programs
          are "mostly compatible", they're incompatible in a few fundamental
          areas. Obviously, these incompatibilities aren't discovered by the
          developer until runtime. OpenGL ES3 claims compatibility with 3.0,
          but of course deviates from the 3.0 specification in many minor
          areas.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.problems.types">
        <s:subsection-title>Types</s:subsection-title>
        <s:paragraph>
          The OpenGL API itself is weakly typed even for a C language API, simply
          exposing absolutely everything as a <s:term s:type="type">float</s:term>,
          <s:term s:type="type">int</s:term>, or untyped pointer. Entire classes
          of problems that should be prevented at compile time are moved to
          run-time, increasing development time, developer frustration, and
          testing burden.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.problems.silent_failure">
        <s:subsection-title>Silent failure</s:subsection-title>
        <s:paragraph>
          OpenGL programs frequently fail, and when they do, they usually do
          so silently. Programmers are forced to call
          <s:term s:type="function">glGetError</s:term> after every API call
          if they wish to avoid this (and actually detect the error at the
          correct function call).
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section>
      <s:section-title>Goals</s:section-title>
      <s:subsection>
        <s:subsection-title>Overview</s:subsection-title>
        <s:paragraph>
          Given the
          <s:link s:target="rationale.problems">problems</s:link>
          with OpenGL, the <s:term s:type="package">jcanephora</s:term> package
          has the following goals (in no particular order):
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.goals.portability">
        <s:subsection-title>Portability</s:subsection-title>
        <s:paragraph>
          Programs using the <s:term s:type="package">jcanephora</s:term> APIs
          must run on as many different OpenGL implementations as possible.
          Code written using the API should be version branch-free, and use only the
          features common to all available OpenGL implementations. Where features
          are too useful to be excluded just for the sake of supporting old
          versions, they are exposed in a manner that indicates
          <s:term s:type="emphasis">statically</s:term> where version-specific
          features have been used.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.goals.type_safety">
        <s:subsection-title>Type safety</s:subsection-title>
        <s:paragraph>
          Representing every object as an integer is unacceptable. Any
          conceptually distinct objects must be made type-incompatible,
          eliminating entire classes of bugs typical to OpenGL programs
          at compile time.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.goals.linearity">
        <s:subsection-title>Linearity</s:subsection-title>
        <s:paragraph>
          Branching, version-specific code must be eliminated as far as
          is possible. Code of this type is fragile, difficult to test,
          and usually incorrect.
        </s:paragraph>
      </s:subsection>
      <s:subsection xml:id="rationale.goals.conspicuity">
        <s:subsection-title>Conspicuity of errors</s:subsection-title>
        <s:paragraph>
          Silent failure of programs is unacceptable. All errors that
          cannot be prevented statically must be loudly and immediately
          signalled at runtime.
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section>
      <s:section-title>API Design</s:section-title>
      <s:subsection xml:id="rationale.solutions.interfaces">
        <s:subsection-title>Interfaces</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">jcanephora</s:term> package attempts
          to combat the problems with OpenGL's idea of
          <s:link s:target="rationale.problems.versioning">versioning</s:link>,
          the actual
          <s:link s:target="rationale.problems.availability">availability</s:link>
          of implementations, and the presence of
          <s:link s:target="rationale.problems.embedded">embedded not-actually-subsets</s:link>
          of the API, by identifying the most widely-deployed versions of OpenGL
          at present (OpenGL 2.1, OpenGL 3.1, and ES2) and then
          by identifying the non-deprecated, arguably future-proof, and common
          subset of the versions in question.
        </s:paragraph>
        <s:paragraph>
          The package then provides interface types that expose the functionality of 
          varying parts of this common subset. Developers know, unambiguously,
          on which versions of OpenGL their code will run simply by looking at
          the interface types their code uses. The package tends to only
          provide those things that are required to be provided according to
          the OpenGL specification. Exceptions to this rule are made when,
          for example,  OpenGL driver limitations force the use of extensions.
        </s:paragraph>
        <s:paragraph>
          The developer interacts with the 
          <s:term s:type="package">jcanephora</s:term> package via the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLImplementationType.html">JCGLImplementationType</s:link-external>
          interface. The <s:term s:type="type">JCGLImplementationType</s:term> interface,
          unsurprisingly, represents the current OpenGL implementation. The
          <s:term s:type="type">JCGLImplementationType</s:term> interface allows access
          to interfaces such as
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLInterfaceGLES2Type.html">JCGLInterfaceGLES2Type</s:link-external>
          (if the current implementation provides OpenGL ES2),
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLInterfaceGL3Type.html">JCGLInterfaceGL3Type</s:link-external>
          (if the current implementation provides OpenGL 3.*), and
          also to
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLInterfaceCommonType.html">JCGLInterfaceCommonType</s:link-external>,
          representing the common subset of all available versions.
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="type">JCGLInterface*</s:term> types statically
          control access to features of the current OpenGL implementation and
          essentially aggregate a set of smaller interfaces. For example,
          the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLArrayBuffersType.html">JCGLArrayBuffersType</s:link-external>
          interface represents the
          <s:link-external s:target="http://opengl.org/wiki/Vertex_Buffer_Object">vertex buffer object</s:link-external>
          functionality common to both OpenGL 3.*, OpenGL ES2, and OpenGL ES3. The
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLArrayBuffersMappedType.html">JCGLArrayBuffersMappedType</s:link-external>
          interface, however, provides the extra functionality only supported
          by OpenGL 3.* and ES3 and is therefore not available via the
          <s:term s:type="type">JCGLInterfaceGLES2Type</s:term> interface.
        </s:paragraph>
        <s:paragraph>
          An extremely useful consequence of the way that the
          <s:term s:type="package">jcanephora</s:term> interfaces are structured
          is that developers can indicate at the level of types which versions
          of OpenGL their code can work with. They can even go so far as to
          specify these dependencies at the granularity of features
          ("this code will work with any OpenGL implementation supporting
          unmapped vertex buffer objects, and 2D textures"):
        </s:paragraph>
        <s:formal-item s:type="implications" s:kind="implications">
          <s:formal-item-title>Compatibility implications of interfaces</s:formal-item-title>
          <s:table>
            <s:table-summary>Compatibility implications of interfaces</s:table-summary>
            <s:table-head>
              <s:table-column-name>The developer writes a function parameterized by:</s:table-column-name>
              <s:table-column-name>This implies:</s:table-column-name>
            </s:table-head>
            <s:table-body>
              <s:table-row>
                <s:table-cell><s:verbatim>JCGLImplementationType</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>JCGLInterfaceGLES2Type</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL ES2 implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>JCGLInterfaceGLES3Type</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL ES3 implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>JCGLInterfaceGL2Type</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL 2.1 implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>JCGLInterfaceGL3Type</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any OpenGL 3.* implementation</s:table-cell>
              </s:table-row>
              <s:table-row>
                <s:table-cell><s:verbatim>G extends JCGLArrayBuffersType &amp; JCGLTextures2DStaticCommonType</s:verbatim></s:table-cell>
                <s:table-cell>The function works on any implementation supporting vertex buffer objects and 2D textures</s:table-cell>
              </s:table-row>
            </s:table-body>
          </s:table>
        </s:formal-item>
        <s:paragraph>
          The interfaces described in this section contribute towards
          the goals of <s:link s:target="rationale.goals.portability">portability</s:link>
          and
          <s:link s:target="rationale.goals.type_safety">type safety</s:link>.
        </s:paragraph>
      </s:subsection>
      
      <s:subsection xml:id="rationale.solutions.capabilities">
        <s:subsection-title>Interfaces as capabilities</s:subsection-title>
        <s:paragraph>
          The package is written with one particular concept, throughout:
          Types represent capabilities. If the developer has a value of a
          given type, then the developer can perform all of the operations
          associated with that type. This is a direct attempt at the goal
          of <s:link s:target="rationale.goals.linearity">linearity</s:link>.
        </s:paragraph>
        <s:paragraph>
          This is in direct contrast to the OpenGL
          API, where the developer always has full access to all API functions,
          and individual functions (or combinations of parameters to functions)
          may not work based on what the implementation supports. The emphasis
          is on <s:term s:type="emphasis">isolating the correct operations and
          statically preventing incorrect operations from occurring</s:term>.
        </s:paragraph>
        <s:paragraph>
          One example of the "capability" based design is the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLRenderbuffersGL3Type.html">JCGLRenderbuffersGL3Type</s:link-external>
          and
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLRenderbuffersGLES2Type.html">JCGLRenderbuffersGLES2Type</s:link-external>
          interfaces. The specifications for OpenGL ES2 and OpenGL 3.0 do
          not require a color-renderable framebuffer format that is common
          to both. Therefore, the <s:term s:type="type">JCGLRenderbuffersGL3Type</s:term>
          interface allows the allocation of texture types specific to OpenGL 3.0,
          and the <s:term s:type="type">JCGLRenderbuffersGLES2Type</s:term> interface
          provides texture types specific to OpenGL ES2. A developer using
          the package will be presented with an
          <s:term s:type="type">JCGLRenderbuffersGL3Type</s:term> interface when code
          is running on OpenGL 3.0, and an
          <s:term s:type="type">JCGLRenderbuffersGLES2Type</s:term> interface when
          code is running on OpenGL ES2, thus
          <s:term s:type="emphasis">statically preventing an attempt to allocate an unsupported format</s:term>.
          Of course, some ES2 and 3.0 implementations do have color-renderable
          formats in common, but a portable program cannot assume this as it
          is not required by the OpenGL specification.
        </s:paragraph>
      </s:subsection>
      
      <s:subsection xml:id="rationale.solutions.types">
        <s:subsection-title>Types</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">jcanephora</s:term> package wraps all
          conceptually distinct objects in new types and provides sane and
          unsurprising functions to construct them. This prevents large
          classes of bugs from occurring, at compile time. It also allows
          the interfaces to be self-documenting. Consider the following
          C function prototype:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Weakly typed C function</s:formal-item-title>
          <s:verbatim>void _ (GLsizei, GLuint *)</s:verbatim>
        </s:formal-item>
        <s:paragraph>
          What does the function do? It could generate a set of textures
          (<s:term s:type="function">glGenTextures</s:term>), or it could
          generate a set of new buffer names
          (<s:term s:type="function">glGenBuffers</s:term>). Without carefully
          reading the documentation, the required parameters to the function
          are certainly not obvious from the type alone. Assuming the developer
          has read the documentation and worked out that the correct way to
          call the function is with the following sequence:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Weakly typed C calls</s:formal-item-title>
          <s:verbatim><![CDATA[GLuint texture;

glGenTextures(1, &texture);
checkGLErrors();]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The developer now has a value of type
          <s:term s:type="type">GLuint</s:term>. Given that many functions in
          the OpenGL API also take values of <s:term s:type="type">GLuint</s:term>,
          and those values have nothing to do with textures, that's a huge
          number of potential bugs that cannot be prevented by the compiler.
        </s:paragraph>
        <s:paragraph>
          The developer now wants to allocate a new RGBA texture. The
          types of the <s:term s:type="function">glTexImage2D</s:term>
          and <s:term s:type="function">glTexParameteri</s:term> functions
          are, quite frankly, insane. Almost no developer manages to use these
          functions successfully without trial and error, and naturally all
          errors are runtime errors. Eventually, through some painful
          experimentation, the developer might stumble onto the following
          sequence of calls:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Allocating a texture</s:formal-item-title>
          <s:verbatim><![CDATA[GLuint texture;
void *data = makeTextureData();

glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 256, 256, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The types of the parameters to all of the functions mentioned allow
          the developer to pass in practically anything. Only a very small
          subset of the possible parameters are actually valid. An even
          smaller subset of the possible parameters actually work across
          different versions of OpenGL!
        </s:paragraph>
        <s:paragraph> 
          Now consider the
          following <s:term s:type="package">jcanephora</s:term> function:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Texture allocation?</s:formal-item-title>
          <s:verbatim><![CDATA[public Texture2DStatic _(
  final String _,
  final int _,
  final int _,
  final TextureWrapS _,
  final TextureWrapT _,
  final TextureFilterMinification _,
  final TextureFilterMagnification _)
    throws JCGLException;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Even without the names of the function and the parameters,
          the type above make it quite clear that the function returns a
          <s:term s:type="type">Texture2DStatic</s:term>, which is somehow
          derived from the arguments to the function. It's a reasonable
          assumption to make that the function allocates a new texture.
        </s:paragraph>
        <s:paragraph>
          The wrapping modes on the <s:term s:type="constant">S</s:term> and
          <s:term s:type="constant">T</s:term> axis will presumably be
          derived from the parameters of type
          <s:term s:type="type">TextureWrapS</s:term> and
          <s:term s:type="type">TextureWrapT</s:term> respectively. The
          minification and magnification filters will presumably be derived
          from the parameters of type
          <s:term s:type="type">TextureFilterMinification</s:term> and
          <s:term s:type="type">TextureFilterMagnification</s:term>,
          respectively. The programmer is statically prevented from mixing
          up the two axes, or the two filter domains.
        </s:paragraph>
        <s:paragraph>
          The two parameters of type <s:term s:type="type">int</s:term>
          presumably correspond to the width and height of the resulting
          texture, but the types are not descriptive enough to say for sure.
          Unfortunately, Java lacks a way to make existing arithmetic types
          incompatible without sacrificing efficiency
          <s:footnote>
            New types will be new classes, resulting in all integers being
            replaced with pointers to integers.
          </s:footnote>. In this case, the two parameters do indeed
          correspond to the width and height, in that order, and the
          <s:term s:type="package">jcanephora</s:term> package uses this
          order consistently throughout.
        </s:paragraph>
        <s:paragraph>
          The errors that the function may raise are also clearly marked as
          checked exceptions.
        </s:paragraph>
        <s:paragraph>
          Some information is still missing, of course, such as the format
          (such as 32-bit RGBA) and type (such as 2D or cube map) of the
          resulting texture. The full name and type of the function is given
          in the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLTextures2DStaticGL3ES3Type.html">JCGLTextures2DStaticGL3ES3Type</s:link-external>
          interface:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>texture2DStaticAllocateRGBA8888</s:formal-item-title>
          <s:verbatim><![CDATA[public Texture2DStatic texture2DStaticAllocateRGBA8888(
  final String name,
  final int width,
  final int height,
  final TextureWrapS wrap_s,
  final TextureWrapT wrap_t,
  final TextureFilterMinification min_filter,
  final TextureFilterMagnification mag_filter)
    throws JCGLException;]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The function allocates a 2D RGBA texture with
          <s:term s:type="constant">8</s:term> bits of precision per channel.
          The texture will be <s:term s:type="variable">width</s:term> texels
          wide, and <s:term s:type="variable">height</s:term> texels tall. The
          texture will be assigned the name
          <s:term s:type="variable">name</s:term>, useful for debugging and
          logging (by convention, this is the filename containing the original
          texture's image, if any).
        </s:paragraph>
        <s:paragraph>
          The extremely descriptive type given for the function, and the
          presence of checked exceptions are direct contributions towards
          the goals of
          <s:link s:target="rationale.goals.type_safety">type safety</s:link>
          and
          <s:link s:target="rationale.goals.conspicuity">conspicuity of errors</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part>
    <s:part-title>jcanephora For OpenGL Programmers</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        As stated repeatedly, the <s:term s:type="package">jcanephora</s:term>
        package strives for increased static and run-time type safety. This
        does, however, mean that there are new abstractions to learn. This
        section of the documentation attempts to describe how to use the API
        for those already familiar with OpenGL. It presents small programs
        written in C and then shows the <s:term s:type="package">jcanephora</s:term>
        equivalent. For the sake of brevity, the C programs often use the
        obsolete fixed-function pipeline (otherwise each example would have
        to implement a lot of tedious matrix math and shading program
        management).
      </s:paragraph>
      <s:paragraph>
        Every <s:term s:type="package">jcanephora</s:term> program begins
        by retrieving an implementation of the
        <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLImplementationType.html">JCGLImplementationType</s:link-external>
        interface. At the time of writing, there is only one implementation based on
        <s:link-external s:target="http://jogamp.org">JOGL</s:link-external>.
        Programs are insulated from the platform/implementation specific
        details of the OpenGL interface via the
        interface types - all operations occur via values of these types and
        client programs do not know anything about the underlying OpenGL
        implementation.
      </s:paragraph>
      <s:paragraph>
        The programmer is expected to know how to initialize
        <s:link-external s:target="http://jogamp.org">JOGL</s:link-external>:
        the details are obviously outside of the scope of this
        documentation. Once initialized, the programmer can then construct a
        <s:link-external s:target="apidocs/com/io7m/jcanephora/jogl/JCGLImplementationJOGL.html">JCGLImplementationJOGL</s:link-external>
        to get access to the <s:term s:type="package">jcanephora</s:term>
        APIs.
      </s:paragraph>
    </s:section>
    <s:section xml:id="tutorial_vbo">
      <s:section-title>Vertex Buffer Objects</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external s:target="c/vbo.c">vbo.c</s:link-external>]
        demonstrates the creation of vertex buffer and index buffer objects
        in plain OpenGL. It creates buffers and then draws them to the screen
        using the fixed-function OpenGL pipeline.
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Vertex buffers (C)</s:formal-item-title>
        <s:verbatim><xi:include href="c/two-triangles.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term s:type="package">jcanephora</s:term> version demonstrates
        many of the package's convenience and safety features:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Vertex buffers (Java)</s:formal-item-title>
        <s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleTriangle.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The program creates a new shading language program with the
        <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLShadersCommonType.html">JCGLShadersCommonType</s:link-external>
        interface. This interface gives easy and type-safe access to the uniform and
        attribute variables present in the program.
      </s:paragraph>
      <s:paragraph>
        The program allocates an
        <s:link-external s:target="apidocs/com/io7m/jcanephora/ArrayBufferType.html">array buffer</s:link-external>
        by creating an explicit description of the type of its elements with an
        <s:link-external s:target="apidocs/com/io7m/jcanephora/ArrayDescriptor.html">ArrayDescriptor</s:link-external>,
        and then allocating a given number of them.
      </s:paragraph>
      <s:paragraph>
        Using the type information given when the array buffer was created, the program
        obtains access to the elements of the array by using typed
        <s:link-external s:target="apidocs/com/io7m/jcanephora/CursorType.html">Cursors</s:link-external>.
        The cursors
        can only point to the specific attributes for which they are intended and refuse
        attempts to write to memory outside of the array data. The cursors also check the
        types of their intended attributes on creation and loudly refuse attempts to write
        to attributes that do not have the expected type. These features eliminate large
        classes of bugs usually associated with doing this kind of low-level memory
        management in C.
      </s:paragraph>
      <s:paragraph>
        The program allocates an
        <s:link-external s:target="apidocs/com/io7m/jcanephora/IndexBufferType.html">index buffer</s:link-external>
        by using the array buffer as a hint. This
        allows the <s:term s:type="package">jcanephora</s:term> package to pick the most
        efficient type for individual indices: If an array buffer has fewer than 256 vertices,
        for example, then there is no reason for the index buffer to use two or four-byte
        indices. This gives significant GPU memory savings whilst presenting a uniform
        interface to the programmer. It is also possible for the programmer to specify
        the types of indices directly, but that is not shown here.
      </s:paragraph>
      <s:paragraph>
        The program passes uniform values to the program over a simple and type-checked
        analogue to the <s:term s:type="function">glUniform*</s:term> interface. Attempting
        to pass a value of the wrong type is prevented at run-time.
      </s:paragraph>
      <s:paragraph>
        The program associates array buffer attributes with program attributes using
        a type-safe interface.
      </s:paragraph>
      <s:paragraph>
        In all cases, the API also tracks whether or not objects have been deleted
        (using a simple flag on the client side), and loudly signals when OpenGL resources
        that have been deleted are passed to various API functions. It would be an error,
        for example, to call the <s:term s:type="function">drawElements</s:term> function
        pictured when the array or index buffer had been deleted.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Textures</s:section-title>
      <s:paragraph>
        The following C program
        [<s:link-external s:target="c/texture-simple.c">texture-simple.c</s:link-external>]
        demonstrates the creation and usage of textures. It generates a simple
        texture and displays it on a rectangle. The program uses the obsolete fixed-function
        pipeline for brevity, as previously mentioned.
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Textures (C)</s:formal-item-title>
        <s:verbatim><xi:include href="c/texture-simple.c" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        The <s:term s:type="package">jcanephora</s:term> version again demonstrates
        many of the package's convenience and safety features:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Textures (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleTexturedQuad.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        In addition to the features demonstrated in the
        <s:link s:target="tutorial_vbo">previous example</s:link>, the
        program demonstrates a number of features specific to texturing.
      </s:paragraph>
      <s:paragraph>
        The program requests access to a list of the available texture units. This
        eliminates a class of bugs present in many programs that use
        <s:term s:type="function">glActiveTexture</s:term>: Most implementations support
        between 16-32 texture units, at the time of writing. OpenGL will raise an error
        if a program attempts to use more than the available number of units, but most
        programs also fail to check OpenGL error codes. The design of the
        <s:term s:type="package">jcanephora</s:term> API models texture units as concrete
        objects of type
        <s:link-external s:target="apidocs/com/io7m/jcanephora/TextureUnitType.html">TextureUnitType</s:link-external>
        and therefore programs cannot accidentally use more units than the implementation
        provides.
      </s:paragraph>
      <s:paragraph>
        The <s:term s:type="package">jcanephora</s:term> hides the ridiculously complicated,
        type-unsafe and legacy-ridden <s:term s:type="function">glTexImage2D</s:term>,
        <s:term s:type="function">glTexSubImage2D</s:term>, and
        <s:term s:type="function">glTexParameter</s:term> interfaces
        and instead exposes sets of allocation functions that take values of various
        <s:term s:type="keyword">enum</s:term> types specifying the exact properties of the
        texture to be allocated. The texture type information is stored (client side) along
        with the details of the allocated texture, allowing type-safe access to texture data
        later on. Many of the combinations of parameters to the raw OpenGL functions
        are invalid, according to the OpenGL specifications. This API rejects the
        invalid combinations statically.
      </s:paragraph>
      <s:paragraph>
        The program updates the allocated texture by creating a new
        <s:link-external s:target="apidocs/com/io7m/jcanephora/Texture2DStaticUpdateType.html">client-side buffer of data</s:link-external>
        and then obtaining access to the data via a
        <s:link-external s:target="apidocs/com/io7m/jcanephora/SpatialCursorType.html">typed cursor</s:link-external>
        interface. It is an error to try to obtain a cursor of the
        wrong type (such as requesting a cursor that points to
        four-component elements in a texture that only contains
        a luminance and alpha channel, for example). The cursor
        interface exposes a uniform interface with regards to color
        data and performs automatic conversion/color packing - the
        program works with simple linear RGBA color values and does
        not need to worry about converting/packing those values into
        the correct format for the texture.
      </s:paragraph>
      <s:paragraph>
        Finally, during rendering, the program binds the texture to a texture unit and
        uploads the name of the texture unit to the shading language program. Naturally,
        all of these operations have increased safety (it's not possible to upload
        an arbitrary integer to a program that expects a
        <s:term s:type="type">sampler2D</s:term> type, for example).
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Shaders</s:section-title>
      <s:paragraph>
        The
        <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLShadersCommonType.html">JCGLShaders</s:link-external>
        interface exposes a mindlessly simple interface to support the
        compilation and use of shading language programs.
      </s:paragraph>
      <s:paragraph>
        Diverging from the convention of showing the C program
        <s:footnote>Because the C version requires
          a large amount of support code; there's no "standard" way to
          write the same program.</s:footnote>
        and the
        <s:term s:type="package">jcanephora</s:term> equivalent, a complete example
        of loading a single triangle into a vertex buffer and drawing it with
        a GLSL shader, using the low-level shading language interface:
      </s:paragraph>
      <s:formal-item s:kind="examples">
        <s:formal-item-title>Shaders (Java)</s:formal-item-title>
<s:verbatim><xi:include href="../../../io7m-jcanephora-examples/src/main/java/com/io7m/jcanephora/examples/ExampleShaders.java" parse="text"/></s:verbatim>
      </s:formal-item>
      <s:paragraph>
        As simple as it is, the
        <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLShadersCommonType.html">JCGLShaders</s:link-external>
        implements further safety checks:
        Empty programs are rejected <s:footnote>
          Some OpenGL implementations cannot handle empty shading language
          programs, therefore they are automatically rejected by
          <s:term s:type="package">jcanephora</s:term> to ensure code stays
          platform-independent.
        </s:footnote>, attempting to upload data to inactive programs is
        an error, and compilation errors are signalled immediately.
      </s:paragraph>
    </s:section>
    <s:section>
      <s:section-title>Everything Else</s:section-title>
      <s:paragraph>
        Modern OpenGL programming consists of little more than vertex buffer
        objects, shaders, and framebuffer objects, and the
        <s:term s:type="package">jcanephora</s:term> API reflects this.
      </s:paragraph>
      <s:paragraph>
        The rest of the <s:term s:type="package">jcanephora</s:term>
        API is concerned with adding type safety to the functions that
        work on the other parts of the OpenGL pipeline. The
        <s:link s:target="core_interfaces">core interfaces</s:link>
        documentation details the rest of the API.
      </s:paragraph>
    </s:section>
  </s:part>

  <s:part xml:id="core_interfaces">
    <s:part-title>jcanephora Core Interfaces</s:part-title>
    <s:part-contents/>
    
    <s:section xml:id="core_interfaces.overview">
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        The <s:term s:type="package">jcanephora</s:term> package
        is separated into a number of "core" interfaces, through which
        all higher-level abstractions/interfaces work.
      </s:paragraph>
      <s:paragraph>
        The various <s:term s:type="type">JCGLInterface*</s:term> types
        are actually aggregations of these core interfaces into convenient
        packages. See the included <s:link-external s:target="apidocs">JavaDoc</s:link-external> for the details of the combinations.
      </s:paragraph>
    </s:section>
    
    <s:section xml:id="core_interfaces.JCGLArrayBuffersType">
      <s:section-title>JCGLArrayBuffersType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLArrayBuffersType.html">JCGLArrayBuffersType</s:link-external>
          interface provides functions for allocating, populating,
          and using array buffers. It provides a typed interface
          to the <s:term s:type="function">glGenBuffers</s:term>,
          <s:term s:type="function">glBufferData</s:term>, and
          the various vertex attribute functions.
        </s:paragraph>
        <s:paragraph>
          In <s:term s:type="package">jcanephora</s:term>, array
          buffers are considered to be arrays of
          <s:term s:type="term">elements</s:term> of a given
          record <s:footnote>Or "struct" in C's terminology.</s:footnote>
          type <s:term s:type="variable">T</s:term>.
          The programmer describes the type <s:term s:type="variable">T</s:term>,
          allocates an array of
          <s:term s:type="variable">n</s:term> elements of
          <s:term s:type="variable">T</s:term>, and then populates
          the array with values via a typed cursor interface.
          The type <s:term s:type="variable">T</s:term> is described
          by constructing values of the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/ArrayDescriptor.html">ArrayDescriptor</s:link-external>
          type, which is essentially an array of
          <s:link-external s:target="apidocs/com/io7m/jcanephora/ArrayAttributeDescriptor.html">ArrayAttributeDescriptor</s:link-external>
          values. See the usage examples for more information.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          First, consider a fairly standard vertex type: A position
          in world space consisting of four floating point
          values representing the <s:term s:type="variable">(x, y, z, w)</s:term>
          coordinates, a three-dimensional normal vector in
          object space, and a set of two-dimensional
          <s:term s:type="variable">(s, t)</s:term> texture coordinates. The
          type descriptor for this type is declared as follows:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Vertex type descriptor</s:formal-item-title>
<s:verbatim><![CDATA[ArrayDescriptorBuilderType b = ArrayDescriptor.newBuilder();

b.addAttribute(ArrayAttributeDescriptor.newAttribute("position", JCGLScalarType.TYPE_FLOAT, 4));
b.addAttribute(ArrayAttributeDescriptor.newAttribute("normal", JCGLScalarType.TYPE_FLOAT, 3));
b.addAttribute(ArrayAttributeDescriptor.newAttribute("uv", JCGLScalarType.TYPE_FLOAT, 2));

ArrayDescriptor d = b.build();]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The order of the elements passed to the
          <s:term s:type="type">ArrayDescriptorBuilderType</s:term> builder
          is significant: the values of each field will be packed into
          any array allocated using this type descriptor in the order that
          they are given to the builder. In the above example, the
          <s:term s:type="constant">"position"</s:term> field is
          <s:term s:type="expression">4 * 4 = 16</s:term> bytes in size, and
          will be placed at <s:term s:type="expression">0</s:term> bytes past
          the start of each element. The <s:term s:type="constant">"normal"</s:term>
          field is
          <s:term s:type="expression">3 * 4 = 12</s:term> bytes in size, and
          will be placed at
          <s:term s:type="expression">16</s:term> bytes past the start
          of each element, because it will be placed directly after the
          <s:term s:type="constant">"position"</s:term> field. Finally, the
          <s:term s:type="constant">"texture"</s:term> field is
          <s:term s:type="expression">2 * 4 = 8</s:term> bytes in size,
          and will be placed at
          <s:term s:type="expression">16 + 12 = 28</s:term> bytes past
          the start of each element, because it will be placed directly
          after the "position" and "normal" fields. The size of each
          element in the array is therefore
          <s:term s:type="expression">16 + 12 + 8 = 36</s:term> bytes. The
          <s:term s:type="type">ArrayBufferTypeDescriptor</s:term> value
          can be queried after construction to obtain these values, if
          desired:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Vertex sizes and offsets</s:formal-item-title>
<s:verbatim><![CDATA[
d.getAttributeOffset("position") == 0

d.getAttributeOffset("normal") == 16

d.getAttributeOffset("texture") == 28

d.getElementSizeBytes() == 36
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Then, to allocate an array that will hold <s:term s:type="constant">100</s:term>
          elements of this type:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Array allocation</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLArrayBuffersType g;

ArrayBufferType a = g.arrayBufferAllocate(100, d, UsageHint.USAGE_STATIC_DRAW);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          An array of elements is allocated on the GPU, and an immutable
          reference to this array is returned. The array initially contains
          no data, and must then be populated with data using the
          <s:term s:type="package">jcanephora</s:term> equivalent of the
          <s:term s:type="function">glBufferSubData</s:term> function. See
          the <s:link s:target="core_interfaces.JCGLArrayBuffersMappedType">JCGLArrayBuffersMappedType</s:link>
          interface for an alternative method of populating arrays on
          more advanced OpenGL implementations. The
          <s:term s:type="package">jcanephora</s:term>
          package provides a typed "cursor" interface that provides a
          safe and convenient way to get data into arrays, without any
          risk of uploading incorrectly packed data, as is common for
          most OpenGL programs. First, it's necessary to create a value
          of type
          <s:link-external s:target="apidocs/com/io7m/jcanephora/ArrayBufferUpdateUnmappedType.html">ArrayBufferUpdateUnmappedType</s:link-external>.
          This allocates an array of bytes in the program's address space
          that will be used to hold data that will be uploaded to the array
          on the GPU:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Array writable data</s:formal-item-title>
<s:verbatim><![CDATA[
ArrayBufferUpdateUnmappedType ad = ArrayBufferUpdateUnmapped.newUpdateReplacingAll(a);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          It's also possible to supply an inclusive range of elements
          to perform partial updates to array data. Then, it's necessary to
          obtain access to cursors for each of the three attribute types
          declared earlier. The type of cursor requested must match the
          type of attribute exactly; the API will raise an exception if
          the programmer asks for a three-element cursor to an attribute
          that has four elements, for example.
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Array cursors</s:formal-item-title>
<s:verbatim><![CDATA[
CursorWritable4fType cp = ad.getCursor4f("position");
CursorWritable3fType cn = ad.getCursor3f("normal");
CursorWritable2fType ct = ad.getCursor2f("texture");
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Cursors traverse the array sequentially, with each new element
          of data provided moving the cursor to the next array element.
          Cursors are fully independent and so it is not necessary to
          provide data to all of the fields above at once (it might be
          desirable in some programs to provide all of the position data
          first, then all of the normal data, and then all of the texture
          coordinates, for example).
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Array cursor writing</s:formal-item-title>
<s:verbatim><![CDATA[
while (cp.hasNext()) {
  cp.put4f(x, y, z, w);
}

while (cn.hasNext()) {
  cn.put3f(nx, ny, nz);
  ct.put2f(s, t);
}

assert cp.hasNext() == false;
assert cn.hasNext() == false;
assert ct.hasNext() == false;
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Typically, data will be provided in a loop as shown above, but
          it is also possible to seek cursors to specific elements in the
          array. The API will raise exceptions if the programmer attempts
          to write outside the bounds of the array. Finally, the data
          is uploaded to the array on the GPU: 
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Array data upload</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLArrayBuffersType g;

g.arrayBufferUpdate(ad);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The <s:term s:type="package">jcanephora</s:term> package, for
          better or worse, retains OpenGL's concept of a currently
          "bound" array buffer. Most functions require that an array
          buffer be bound before any operations occur on it, and
          no functions outside of the array API will modify the current 
          array buffer binding. At most one buffer can be bound at
          a time, and buffers are bound and unbound with the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLArrayBuffersType.html#arrayBufferBind(com.io7m.jcanephora.ArrayBufferUsableType)">arrayBufferBind</s:link-external>
          and
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLArrayBuffersType.html#arrayBufferUnbind()">arrayBufferUnbind</s:link-external>
          functions, respectively.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions, and appear
          to behave identically.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          OpenGL's error-prone, untyped approach to array buffers
          is categorically rejected and replaced with an approach
          that emphasizes as much compile-time and runtime safety
          as possible.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLArrayBuffersMappedType">
      <s:section-title>JCGLArrayBuffersMappedType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLArrayBuffersMappedType.html">JCGLArrayBuffersMappedType</s:link-external>
          interface provides functions to map array buffers allocated
          on the GPU to the address space of the client, in order to
          be read or modified. This gives significant memory savings,
          as it's not necessary to allocate an intermediate array of
          data in order to modify an existing array buffer.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          The
          <s:link-external s:target="apidocs/com/io7m/jcanephora/ArrayBufferUpdateMappedType.html">ArrayBufferUpdateMappedType</s:link-external>
          interface provides a more or less drop-in replacement for
          the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/ArrayBufferUpdateUnmappedType.html">ArrayBufferUpdateUnmappedType</s:link-external>
          interface. First, a writable map is obtained for an existing
          array buffer <s:term s:type="variable">a</s:term> (note that
          obtaining a writable map of an array buffer immediately
          deletes any existing contents of the array buffer, to
          prevent pipeline stalls on the GPU):
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Array map</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLArrayBuffersMappedType g;

map = g.arrayBufferMapWrite(a);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Then, the map is modified using the same cursor interface
          as with the <s:term s:type="type">ArrayBufferUpdateUnmappedType</s:term>
          type. The buffer should be unmapped after use:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Array map</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLArrayBuffersMappedType g;

g.arrayBufferUnmap(a);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          OpenGL ES 2 does not support mapping buffers. Some vendors
          might provide extensions, but <s:term s:type="package">jcanephora</s:term>
          doesn't use them (as they aren't guaranteed to be available).
          OpenGL 2.1 does support mapping of buffers in some form, but
          it is crippled to the point of being almost unusable, so it
          is not exposed in <s:term s:type="package">jcanephora</s:term>
          on 2.1 implementations. OpenGL ES 3 supports buffer mapping,
          as does OpenGL 3.0 core and beyond, so it is available in
          <s:term s:type="package">jcanephora</s:term> on those
          implementations.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          See the <s:link s:target="core_interfaces.JCGLArrayBuffersType">JCGLArrayBuffersType</s:link>
          interface.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLBlendingType">
      <s:section-title>JCGLBlendingType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLBlendingCommonType.html">JCGLBlending*</s:link-external>
          interfaces provide functions for configuring framebuffer
          color blending.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To enable blending, using the fairly typical
          <s:term s:type="expression">color = (destination * source_alpha) + (source * (1.0 - source_alpha))</s:term>
          blending equation:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Blending</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLBlendingCommonType g;

g.blendingEnable(
  BlendFunction.BLEND_SOURCE_ALPHA,
  BlendFunction.BLEND_ONE_MINUS_SOURCE_ALPHA);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          OpenGL 3.* and ES2 differ in their support of blending. ES2 supports
          somewhat fewer blending functions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          In typical style, integer constants are replaced with
          enumerated types, making it statically impossible to
          pass nonsense values to the functions.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLColorBufferType">
      <s:section-title>JCGLColorBufferType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLColorBufferType.html">JCGLColorBufferType</s:link-external>
          interface defines some primitive operations on color buffers.
          The interface essentially provides a more strongly-typed
          and literal interface around the <s:term s:type="function">glClear</s:term>
          and <s:term s:type="function">glColorMask</s:term> functions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To clear the current color buffer to an opaque red:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Color buffer clear</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLColorBufferType g;

g.colorBufferClear3f(1.0f, 0.0f, 0.0f);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          To discard all writes to the green channel of the current
          color buffer:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Color buffer mask</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLColorBufferType g;

g.colorBufferMask(true, false, true, true);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions, and appear
          to behave identically.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="function">glClear</s:term> and
          <s:term s:type="function">glColorMask</s:term> functions
          are somewhat weakly typed. It's not really possible to
          work out how to use them without checking the
          documentation. The functions provided in the
          <s:term s:type="package">JCGLColorBufferType</s:term> interface
          are somewhat more self-documenting and are much more
          difficult to use incorrectly.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLCullType">
      <s:section-title>JCGLCullType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLCullType.html">JCGLCullType</s:link-external>
          interface provides functions for configuring back-face culling.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To enable back-face culling and to specify that front faces
          are specified with a counter-clockwise winding order (the
          OpenGL defaults):
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Culling</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLCullType g;

g.cullingEnable(
  FaceSelection.FACE_CULL_BACK,
  FaceWindingOrder.FRONT_FACE_COUNTER_CLOCKWISE);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          The interface reflects the minimum supported by OpenGL ES2.
          All other OpenGL versions support a (not commonly used)
          superset of the functionality.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          In typical style, integer constants are replaced with
          enumerated types, making it statically impossible to
          pass nonsense values to the functions.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLDepthBufferType">
      <s:section-title>JCGLDepthBufferType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLDepthBufferType.html">JCGLDepthBufferType</s:link-external>
          interface defines some primitive operations on depth buffers.
          The interface essentially provides a more strongly-typed
          and literal interface around the <s:term s:type="function">glClear</s:term>,
          <s:term s:type="function">glDepthMask</s:term>, and
          <s:term s:type="function">glDepthFunc</s:term> functions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To clear the current depth buffer to a value typical of the far clipping plane:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Depth buffer clear</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLDepthBuffers g;

g.depthBufferClear(1.0f);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          To discard all writes to the depth buffer (note that this will
          also prevent clearing of the depth buffer):
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Depth buffer mask</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLDepthBuffers g;

g.depthBufferWriteDisable();
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          To enable depth testing and set the depth function such that
          only depth values less than the current value in the depth buffer will
          be written:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Depth buffer enable</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLDepthBuffers g;

g.depthBufferTestEnable(DepthFunction.DEPTH_LESS_THAN);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          Obtaining the size of the current depth buffer is
          incredibly platform-specific in some cases and there
          are few guarantees about what kind of depth buffer will
          be provided by implementations by default. The functions
          otherwise behave identically on all OpenGL versions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="function">glClear</s:term> and
          <s:term s:type="function">glDepthMask</s:term> functions
          are somewhat weakly typed. It's not really possible to
          work out how to use them without checking the
          documentation. The functions provided in the
          <s:term s:type="package">JCGLDepthBufferType</s:term> interface
          are somewhat more self-documenting and are much more
          difficult to use incorrectly. Integer constants are
          replaced with enumerated types, making it statically
          impossible to pass nonsense values to the functions. The
          <s:term s:type="function">depthBufferGetBits()</s:term>
          function abstracts over the various platform and
          version-specific nonsense required to obtain the size
          of the current depth buffer (different steps are required
          on different OpenGL versions, and the steps are different
          for windowing-system provided framebuffers and application
          framebuffers, and in the case of the former can often be
          entirely platform specific).
        </s:paragraph>
        <s:paragraph>
          The <s:term s:type="package">JCGLDepthBufferType</s:term> functions
          will raise exceptions when attempting to use them on framebuffer
          configurations that don't have depth buffers: Failing early and
          loudly is considered essential.
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section xml:id="core_interfaces.JCGLDrawType">
      <s:section-title>JCGLDrawType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLDrawType.html">JCGLDrawType</s:link-external>
          interface provides an abstraction around the
          <s:term s:type="function">glDrawElements</s:term> function.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          Assuming that an <s:link s:target="core_interfaces.JCGLArrayBuffersType">array buffer</s:link>
          is currently bound, and an
          <s:link s:target="core_interfaces.JCGLIndexBuffersType">index buffer</s:link>
          has been populated with data, drawing an object is trivial:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Drawing</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLDrawType gd;
IndexBufferType indices;

g.drawElements(Primitives.PRIMITIVE_TRIANGLES, indices);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          OpenGL ES2 supports somewhat fewer primitive types than
          the other OpenGL profiles, but given that their use is
          comparatively rare, the interface only exposes the common
          subset of  primitive types available on all OpenGL versions.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="package">JCGLDrawType</s:term> interface
          exposes the bare minimum required to get something onto
          the screen. It is assumed that all arrays will be indexed
          with an index buffer, as this seems to be universal
          practice and obviously leads to large space savings
          compared to non-indexed arrays.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLFramebuffers">
      <s:section-title>JCGLFramebuffers*</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLFramebuffersCommonType.html">JCGLFramebuffers*</s:link-external>
          interfaces provide functions for allocating and configuring
          framebuffers.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          A <s:term s:type="term">framebuffer</s:term> in OpenGL is an
          opaque structure with one or more <s:term s:type="term">attachments</s:term>.
          Currently, attachments can either be
          <s:link s:target="core_interfaces.JCGLTextures2DStatic">textures</s:link>
          or
          <s:link s:target="core_interfaces.JCGLRenderbuffers">renderbuffers</s:link>.
          Textures are used when the result of rendering to a framebuffer is
          going to be read back at some point, or perhaps used to texture
          other objects. For example, some 3D engines implement so-called
          "procedural textures" by rendering a generated pattern to a texture
          and then applying that texture to objects in the scene. Renderbuffers
          are essentially write-only; typically, the depth buffer in a framebuffer
          configuration is provided as a renderbuffer, as the buffer is used
          during rendering but the results are discarded at the end of each
          rendering frame. Attachments are attached at specific points to
          any given framebuffer: Framebuffers can have a 
          <s:term s:type="term">depth</s:term> attachment, a
          <s:term s:type="term">stencil</s:term> attachment, a
          <s:term s:type="term">depth+stencil</s:term> attachment, and
          an implementation-defined maximum number of
          <s:term s:type="term">color</s:term> attachments.
        </s:paragraph>
        <s:paragraph>
          Allocating a new framebuffer is trivial:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Framebuffer allocation</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLFramebuffersCommonType g;

FramebufferType f = g.framebufferAllocate();
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Unfortunately, at this point, the process immediately becomes
          OpenGL version-specific. There are a number of issues that
          impede cross-version compatibility:
        </s:paragraph>
        <s:formal-item s:kind="listing">
          <s:formal-item-title>Framebuffer version issues</s:formal-item-title>
          <s:list-unordered>
            <s:list-item>OpenGL ES2 permits <s:term s:type="emphasis">at most</s:term> one color attachment.</s:list-item>
            <s:list-item>OpenGL 3.0 requires the implementation to support <s:term s:type="emphasis">at least</s:term> 8 color attachments
              <s:footnote>
                See <s:term s:type="constant">MAX_COLOR_ATTACHMENTS</s:term> in the state tables
                of the OpenGL 3.0 specification (Table 6.51 - "Framebuffer dependent values", page 391).
              </s:footnote>.
            </s:list-item>
            <s:list-item>
              OpenGL ES2 actually forbids implementations from allowing
              rendering to anything other than five specific renderable
              buffer/texture formats
                <s:footnote>
                See the specification for <s:term s:type="function">glRenderbufferStorage</s:term> in
                the OpenGL ES 2.0 specification. Page 111 states: "<s:term s:type="term">internalformat</s:term>
                must be one of the color-renderable, depth-renderable, or stencil-renderable
                formats described in table 4.5". Table 4.5 contains
                <s:term s:type="constant">DEPTH_COMPONENT16</s:term>,
                <s:term s:type="constant">RGBA4</s:term>,
                <s:term s:type="constant">RBGA5_1</s:term>,
                <s:term s:type="constant">RGB565</s:term>, and
                <s:term s:type="constant">STENCIL_INDEX8</s:term>.
              </s:footnote>.
            </s:list-item>
            <s:list-item>
              None of the five specific renderbuffer formats allowed by OpenGL ES2,
              are required to be available by any OpenGL 3.* implementations.
            </s:list-item>
            <s:list-item>
              OpenGL 2.1 only supports framebuffers via a small set of extensions,
              so the available rendering formats are more or less arbitrary and
              implementation-specific. Most implementations support at least 4
              color attachments.
            </s:list-item>
            <s:list-item>
              Of the five formats allowed by OpenGL ES2, only
              <s:term s:type="constant">DEPTH_COMPONENT16</s:term> is depth-renderable
              and <s:term s:type="constant">STENCIL_INDEX8</s:term> is stencil-renderable.
              However (and this is fairly major point): <s:term s:type="emphasis">The
              vast majority of implementations do not support seperate depth and
              stencil attachments!</s:term> To actually use framebuffers on real OpenGL
              ES2 implementations, the programmer must use the ubiquitous
              <s:link-external s:target="http://www.khronos.org/registry/gles/extensions/OES/OES_packed_depth_stencil.txt">OES_packed_depth_stencil</s:link-external>
              extension.
            </s:list-item>
            <s:list-item>
              OpenGL 3.* implementations typically do not support separate depth/stencil
              attachments either, but the specification requires implementations to
              provide <s:term s:type="constant">DEPTH24_STENCIL8</s:term> and
              <s:term s:type="constant">DEPTH32F_STENCIL8</s:term> formats.
            </s:list-item>
            <s:list-item>
              No known implementations support multiple depth, multiple stencil, or
              multiple depth/stencil attachments, even though the API allows it.
            </s:list-item>
            <s:list-item>
              OpenGL 3.* supports the idea of separate "draw" and "read" framebuffers.
              OpenGL ES2 only supports "draw" framebuffers.
            </s:list-item>
          </s:list-unordered>
        </s:formal-item>
        <s:paragraph>
          It follows, from contradictory requirements above, that it's not actually
          possible to have a single code path that can work on all OpenGL ES2, ES3,
          2.1, and 3.* implementations. Essentially, the following logic is required:
        </s:paragraph>
        <s:formal-item s:kind="procedure">
          <s:formal-item-title>Framebuffer approach</s:formal-item-title>
          <s:list-ordered>
            <s:list-item>
              If multiple color buffers are required:
              <s:list-ordered>
                <s:list-item>
                  If the implementation is ES2, give up.
                </s:list-item>
                <s:list-item>
                  If the implementation is 3.* or ES3, allocate textures or
                  renderbuffers in one of the color-renderable formats common
                  to both.
                </s:list-item>
                <s:list-item>
                  If the implementation is 2.1, allocate textures or
                  renderbuffers in one of the color-renderable formats common
                  to both 3.* or ES3, and hope for the best.
                </s:list-item>
              </s:list-ordered>
            </s:list-item>
            <s:list-item>
              If a single color buffer is required:
              <s:list-ordered>
                <s:list-item>
                  If the implementation is ES2, allocate a texture or renderbuffer
                  of one of the two color-renderable formats required by ES2.
                </s:list-item>
                <s:list-item>
                  If the implementation is 3.* or ES3, allocate textures or
                  renderbuffers in one of the color-renderable formats common
                  to both.
                </s:list-item>
                <s:list-item>
                  If the implementation is 2.1, allocate textures or
                  renderbuffers in one of the color-renderable formats common
                  to both 3.* or ES3, and hope for the best.
                </s:list-item>
              </s:list-ordered>
            </s:list-item>
            <s:list-item>
              If a depth or stencil buffer is required:
              <s:list-ordered>
                <s:list-item>
                  If the implementation is ES2:
                  <s:list-ordered>
                    <s:list-item>
                      If the <s:term s:type="constant">OES_packed_depth_stencil</s:term>
                      extension is present, assume that the current implementation cannot
                      handle separate depth/stencil attachments. Allocate a
                      <s:term s:type="constant">DEPTH24_STENCIL8</s:term> texture or
                      renderbuffer and attach it at the
                      <s:term s:type="term">depth+stencil</s:term> attachment point.
                    </s:list-item>
                    <s:list-item>
                      If the <s:term s:type="constant">OES_packed_depth_stencil</s:term>
                      extension is not present, assume that the current implementation
                      does support separate depth/stencil attachments. Allocate a
                      texture or renderbuffer in a depth-renderable or stencil-renderable
                      format and attach it to the
                      <s:term s:type="term">depth</s:term> or <s:term s:type="term">stencil</s:term>
                      attachment point, respectively.
                    </s:list-item>
                  </s:list-ordered>
                </s:list-item>
                <s:list-item>
                  If the implementation is 3.* or ES3, assume that the implementation
                  cannot handle separate depth/stencil attachments.
                  Allocate a <s:term s:type="constant">DEPTH24_STENCIL8</s:term> texture or
                  renderbuffer and attach it at the
                  <s:term s:type="term">depth+stencil</s:term> attachment point.
                </s:list-item>
                <s:list-item>
                  If the implementation is 2.1, , assume that the implementation
                  cannot handle separate depth/stencil attachments. Try to allocate a
                  <s:term s:type="constant">DEPTH24_STENCIL8</s:term> texture or
                  renderbuffer and attach it at the
                  <s:term s:type="term">depth+stencil</s:term> attachment point, and
                  hope for the best.
                </s:list-item>
              </s:list-ordered>
            </s:list-item>
          </s:list-ordered>
        </s:formal-item>
        <s:paragraph>
          To attach allocated textures/buffers to a framebuffer, the API requires
          the programmer to first obtain a list of the available attachment points:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Framebuffer color attachment points</s:formal-item-title>
          <s:verbatim><![CDATA[
JCGLFramebuffersCommonType g;

List<FramebufferColorAttachmentPointType> points = g.framebufferGetColorAttachmentPoints();
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The programmer must pass values of type <s:term s:type="type">FramebufferColorAttachmentPointType</s:term>
          to various attachment functions and is therefore statically prevented from
          trying to use more color attachments than the OpenGL implementation allows.
        </s:paragraph>
        <s:paragraph>
          After allocating a color and depth/stencil renderbuffer, the buffers must
          be attached at the relevant attachment points:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Framebuffer attachments</s:formal-item-title>
          <s:verbatim><![CDATA[
JCGLFramebuffersGL3Type g;
JCGLRenderbuffersGL3ES3Type gr;

List<FramebufferColorAttachmentPointType> points = g.framebufferGetColorAttachmentPoints();
RenderbufferType<RenderableDepthStencilKind> rd = gr.renderbufferAllocateDepth24Stencil8(640, 480);
RenderbufferType<RenderableColorKind> rc = renderbufferAllocateRGB888(640, 480);

FramebufferType f = g.framebufferAllocate();
g.framebufferDrawAttachColorRenderbufferAt(f, points.get(0), rc);
g.framebufferDrawAttachDepthStencilRenderbuffer(f, rd);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          It's then necessary to associate the framebuffer's draw buffers with
          color attachments. That is, it's neccesary to state that if a fragment
          shader writes to a given numbered buffer <s:term s:type="variable">B</s:term>
          when the framebuffer is bound, then that data will be written to color
          attachment <s:term s:type="variable">C</s:term>. As with color attachments,
          the interface requires the programmer to obtain a list of the possible
          draw buffers and then pass in a <s:term s:type="type">Map</s:term>
          associating color attachments to draw buffers. The programmer is therefore
          statically prevented from using more draw buffers than the implementation
          can support:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Framebuffer attachment/buffer mappings</s:formal-item-title>
          <s:verbatim><![CDATA[
JCGLFramebuffersGL3Type g;
FramebufferType f;

List<FramebufferDrawBuffer> buffers = g.framebufferGetDrawBuffers();
List<FramebufferColorAttachmentPoint> points = g.framebufferGetColorAttachmentPoints();

Map<FramebufferDrawBufferType, FramebufferColorAttachmentPointType> mappings =
  new HashMap<FramebufferDrawBufferType, FramebufferColorAttachmentPointType>();
mappings.put(buffers.get(0), points.get(0));

g.framebufferDrawSetBuffers(f, mappings);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Finally, the framebuffer configuration should be validated to ensure
          that the configuration is correct and supported. If the
          validation function returns any status other than
          <s:term s:type="constant">FRAMEBUFFER_STATUS_COMPLETE</s:term>, then
          the framebuffer is incorrectly constructed or unsupported by the
          current implementation, and cannot be used.
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Framebuffer validation</s:formal-item-title>
          <s:verbatim><![CDATA[
JCGLFramebuffersGL3Type g;
FramebufferType f;

FramebufferStatus status = g.framebufferDrawValidate(f);
if (status != FramebufferStatus.FRAMEBUFFER_STATUS_COMPLETE) {
  // Handle failure...
}
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          To render to the framebuffer, the framebuffer must be bound:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Framebuffer binding</s:formal-item-title>
          <s:verbatim><![CDATA[
JCGLFramebuffersGL3Type g;
FramebufferType f;

g.framebufferDrawBind(f);
{
  // Perform rendering.
}
g.framebufferDrawUnbind(f);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          See the usage information above for the various issues.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The framebuffer API supported by all of the OpenGL versions is
          chaotic, inconsistent, and contradictory. The 
          <s:term s:type="package">jcanephora</s:term> package cannot fix
          the contradictions, so it settles for providing type-safe wrappers
          around the existing functions.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLIndexBuffersType">
      <s:section-title>JCGLIndexBuffersType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLIndexBuffersType.html">JCGLIndexBuffersType</s:link-external>
          interface provides functions to allocate and populate
          index buffers. Index buffers (sometimes known as element
          buffers) are used to store indices of elements in
          array buffers. Where an array buffer stores raw vertex
          data, an index buffer stores a sequence of indices that
          are used to extract lines and triangles from the raw
          vertex data.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          Index buffers are allocated and populated in a matter
          similar to
          <s:link s:target="core_interfaces.JCGLArrayBuffersType">array buffers</s:link>:
          An initial size is specified, and a cursor interface is
          used to insert values into the allocated buffer. Typically,
          there is an <s:term s:type="expression">n:1</s:term> relationship
          between index buffers and array buffers. That is, at least
          one index buffer is usually used per array buffer.
        </s:paragraph>
        <s:paragraph>
          It is necessary to specify the type of indices in an index buffer.
          For example, if an array buffer has fewer than
          <s:term s:type="constant">256</s:term> elements then there
          will never be a value greater than
          <s:term s:type="constant">255</s:term> stored in the
          corresponding index buffer, and therefore the indices of
          the index buffer could be 8-bit bytes. If the array buffer
          has fewer than <s:term s:type="constant">65536</s:term> elements,
          then the indices of the index
          buffer could be 16-bit bytes, and so on. It's therefore possible
          to allocate an index buffer by passing it an array buffer as
          a hint: The <s:term s:type="package">jcanephora</s:term> package
          will pick the smallest type that could hold values to address
          all elements of the given array buffer. It's also possible
          to choose the types directly, if desired.
        </s:paragraph>
        <s:paragraph>
          A simple example that allocates an index buffer with four
          elements, given an existing array buffer, and populates it
          with data:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Index buffer usage</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLIndexBuffersType gi;
ArrayBufferType a;

IndexBufferType indices = gi.indexBufferAllocate(a, 4);
IndexBufferUpdateUnmappedType id = IndexBufferUpdateUnmapped.newReplacing(indices);
CursorWritableIndexType c = id.getCursor()

c.putIndex(0);
c.putIndex(1);
c.putIndex(2);
c.putIndex(3);

gi.indexBufferUpdate(indices);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The
          <s:link-external s:target="apidocs/com/io7m/jcanephora/CursorWritableIndexType.html">CursorWritableIndexType</s:link-external>
          type insulates the programmer from having to deal with the
          actual type of indices in the index buffer.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions, and appear
          to behave identically.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          See <s:link s:target="core_interfaces.JCGLArrayBuffersType">JCGLArrayBuffersType</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section xml:id="core_interfaces.JCGLIndexBuffersMappedType">
      <s:section-title>JCGLIndexBuffersMapped</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLIndexBuffersMappedType.html">JCGLIndexBuffersMappedType</s:link-external>
          interface provides functions to map index buffers into
          the application's address space. It is to
          <s:link s:target="core_interfaces.JCGLIndexBuffersType">JCGLIndexBuffersType</s:link>
          as
          <s:link s:target="core_interfaces.JCGLArrayBuffersMappedType">JCGLArrayBuffersMappedType</s:link>
          is to
          <s:link s:target="core_interfaces.JCGLArrayBuffersType">JCGLArrayBuffersType</s:link>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          The interface provided is identical to the
          <s:link s:target="core_interfaces.JCGLArrayBuffersMappedType">JCGLArrayBuffersMappedType</s:link>
          interface, modulo the buffer types. No extra usage
          information is given here.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          See <s:link s:target="core_interfaces.JCGLArrayBuffersMappedType">JCGLArrayBuffersMappedType</s:link>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          See <s:link s:target="core_interfaces.JCGLArrayBuffersType">JCGLArrayBuffersType</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section xml:id="core_interfaces.JCGLLogicType">
      <s:section-title>JCGLLogicType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLLogicType.html">JCGLLogicType</s:link-external>
          interface provides functions to perform logical operations
          when drawing to the current framebuffer (such as XORing all
          incoming color values with those already in the framebuffer).
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To specify that all incoming colors should be XORd with those
          already in the framebuffer:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Logical operations</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLLogic gl;

gl.logicOperationsEnable(LogicOperation.LOGIC_XOR);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          The operations described by the interface are supported
          by OpenGL 2.1 and beyond, but are not supported by any
          version of OpenGL ES.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          In typical style, integer constants are replaced with
          enumerated types, making it statically impossible to
          pass nonsense values to the functions.
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section xml:id="core_interfaces.JCGLMetaType">
      <s:section-title>JCGLMetaType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLMetaType.html">JCGLMetaType</s:link-external>
          interface provides functions to query the current
          OpenGL implementation for various metadata.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To retrieve the current OpenGL shading language version
          as a two-part number:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Shading language version</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLMetaType g;

JCGLSLVersion v = g.metaGetSLVersion();
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions, and give
          results appropriate to each version.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          For some reason, the OpenGL API carefully specifies the
          formats of strings, and then has the programmer parse them.
          If the format is known, why couldn't the values be returned
          directly rather than require parsing?
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section xml:id="core_interfaces.JCGLRenderbuffers">
      <s:section-title>JCGLRenderbuffers*</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLRenderbuffersCommonType.html">JCGLRenderbuffers*</s:link-external>
          interfaces provide functions for allocating and
          deleting renderbuffers.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">JCGLRenderbuffers</s:term> interfaces
          are organized in a similar manner to the
          <s:link s:target="core_interfaces.JCGLTextures2DStatic">JCGLTextures2DStatic*</s:link>
          interfaces in that the allocation functions are separated
          into version-specific interfaces to statically prevent
          the allocation of unsupported formats.
        </s:paragraph>
        <s:paragraph>
          Given the opaque nature of renderbuffers, the interfaces
          do not provide any functions beyond allocation and
          deletion. Once allocated, renderbuffers are attached to
          <s:link s:target="core_interfaces.JCGLFramebuffers">framebuffers</s:link>
          for use, and do not support any other operations.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions, but the
          available renderbuffer formats differ. For example, OpenGL ES 2
          and OpenGL 3.0 do not have a required renderable format in
          common.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          See <s:link s:target="core_interfaces.JCGLTextures2DStatic">JCGLTextures2DStatic</s:link>,
          as the design of the <s:term s:type="type">JCGLRenderbuffers</s:term>
          interfaces mirror those of the texture interfaces.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLScissorType">
      <s:section-title>JCGLScissorType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLScissorType.html">JCGLScissorType</s:link-external>
          interface provides functions for configuring the
          scissor test. No fragments will be rasterized outside
          of the area described by the 2D scissor region.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To specify that only the bottom-left
          <s:term s:type="expression">32 * 32</s:term> pixels of
          the viewport should be affected by rendering:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Scissor region</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLScissorType g;

g.scissorEnable(
  new VectorI2I(0, 0),
  new VectorI2I(31, 31));
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions and appear
          to behave identically.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The interface exposed is slightly more compact than the
          existing OpenGL API.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLShaders">
      <s:section-title>JCGLShaders*</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLShadersCommonType.html">JCGLShaders*</s:link-external>
          interfaces provide functions for allocating, compiling, linking,
          and using shading language programs.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To compile vertex and fragment shaders, simply pass in lists
          of strings, with each string terminated with CRLF or LF
          characters:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Compiling shaders</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLShadersType g;

List<String> v_source = new ArrayList<String>();
v_source.add("#version 330\n");
v_source.add("in vec4 position;\n");
v_source.add("void\n");
v_source.add("main (void)\n");
v_source.add("{\n");
v_source.add("  gl_Position = position;\n");
v_source.add("}\n");

VertexShaderType v = g.vertexShaderCompile("example-v", v_source);

List<String> f_source = new ArrayList<String>();
f_source.add("#version 330\n");
f_source.add("uniform vec4 color;\n");
f_source.add("out vec4 color0;\n");
f_source.add("void\n");
f_source.add("main (void)\n");
f_source.add("{\n");
f_source.add("  color0 = color;\n");
f_source.add("}\n");

FragmentShaderType f = g.fragmentShaderCompiler("example-f", f_source);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          To combine (attach and link) the shaders into a working program:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Producing a program</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLShadersCommonType g;

ProgramReference p = g.programCreateCommon("example", v, f);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Note that this assumes that the fragment shader in question
          only has a single output (which will automatically be mapped
          to draw buffer <s:term s:type="constant">0</s:term> by OpenGL).
          See <s:link s:target="core_interfaces.JCGLShaders.version_support">version support</s:link>
          for details on the difficulties of writing shading programs
          with multiple outputs that will work consistently across
          OpenGL versions. With those issues understood, programs with
          multiple named fragment shader outputs can be compiled with the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLShadersGL3Type.html#programCreateWithOutputs(java.lang.String,%20com.io7m.jcanephora.VertexShaderType,%20com.io7m.jcanephora.FragmentShaderType,%20java.util.Map)">programCreateWithOutputs()</s:link-external>
          function, which is only exposed on OpenGL 3.* implementations:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Compiling shaders with multiple outputs</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLShadersGL3Type g;

List<String> f_source = new ArrayList<String>();
f_source.add("#version 330\n");
f_source.add("uniform vec4 color;\n");
f_source.add("out vec4 output0;\n");
f_source.add("out vec4 output1;\n");
f_source.add("out vec4 output2;\n");
f_source.add("out vec4 output3;\n");
f_source.add("void\n");
f_source.add("main (void)\n");
f_source.add("{\n");
f_source.add("  output0 = color;\n");
f_source.add("  output1 = color.r;\n");
f_source.add("  output2 = color.g;\n");
f_source.add("  output3 = color.b;\n");
f_source.add("}\n");

FragmentShaderType f = g.fragmentShaderCompiler("example-f", f_source);

Map<String, FramebufferDrawBufferType> outputs = new HashMap<String, FramebufferDrawBufferType>();
outputs.put("output0", buffers[0]);
outputs.put("output1", buffers[1]);
outputs.put("output2", buffers[2]);
outputs.put("output3", buffers[3]);

ProgramType p = g.programCreateWithOutputs("example", v, f, outputs);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The function takes a parameter consisting of mappings
          between output names and draw buffers (obtained with the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLFramebuffersCommonType.html#framebufferGetDrawBuffers()">framebufferGetDrawBuffers()</s:link-external>
          function).
        </s:paragraph>
        <s:paragraph>
          The program functions interrogate the compiled program when
          it is created and produce a set of mappings from names
          to active uniforms (parameters). A read-only view of these
          can be accessed via the program reference:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Program uniforms</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLShadersCommonType g;

Map<String, ProgramUniformType> uniforms = p.getUniforms();

ProgramUniformType p = uniforms.get("color");
assert p != null;
g.programActivate(p);
p.programUniformPutVector4f(p, new VectorI4F(1.0f, 0.0f, 0.0f, 1.0f));
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          Attributes are accessed in the same manner, but data must be
          supplied from
          <s:link s:target="core_interfaces.JCGLArrayBuffersType">array buffer attributes</s:link>
          by first binding the array, and then binding the array attribute to
          the given program attribute:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Program attributes</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLShadersCommonType gs;
JCGLArrayBuffersType ga;
ArrayBufferType a;

Map<String, ProgramAttributeType> attributes = p.getAttributes();

ProgramAttributeType pa = attributes.get("position");
assert pa != null;

// Assuming that the array has an attribute named "position".
ArrayAttributeType aa = a.getAttribute("position");

gs.programActivate(p);
ga.arrayBufferBind(a);
gs.programAttributeArrayAssociate(pa, aa);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection xml:id="core_interfaces.JCGLShaders.version_support">
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All of the supported OpenGL versions support the
          compilation and loading of shaders, but every version
          supports a different version of GLSL. OpenGL ES does
          not support the attaching of multiple vertex and
          fragment shaders to a single program, and therefore
          the <s:term s:type="type">JCGLShaders</s:term> interface
          does not either. Being able to attach multiple shaders
          to a single program is of questionable utility when a
          higher-level shading language is used to produce
          monolithic GLSL source.
        </s:paragraph>
        <s:paragraph>
          OpenGL 2.1 fragment shaders must, if not using multiple
          outputs, assign a value to the built-in variable
          <s:term s:type="variable">gl_FragColor</s:term>.
          OpenGL 2.1 allows for multiple fragment shader outputs,
          but they cannot be named (the programmer must assign
          values to the built-in array variable
          <s:term s:type="variable">gl_FragData</s:term>). In OpenGL
          3.0, all fragment shader outputs must be named, as the
          built-in variable <s:term s:type="variable">gl_FragColor</s:term>
          is deprecated. The association of named outputs to
          framebuffer draw buffers is assigned with the
          <s:term s:type="variable">glBindFragDataLocation</s:term>
          function. In OpenGL 3.3 and beyond, fragment shader outputs
          can be assigned to draw buffers statically, with the use
          of the <s:term s:type="keyword">layout</s:term> qualifier.
          In OpenGL ES 2, fragment shaders cannot have multiple
          outputs. OpenGL ES 3 does not have
          <s:term s:type="variable">glBindFragDataLocation</s:term>,
          so outputs must be assigned statically.
        </s:paragraph>
        <s:paragraph>
          OpenGL ES2 places restrictions on the types of attributes
          allowed. Specifically, it only allows the following types
          <s:footnote>See "The OpenGL ES Shading Language 1.0.17", section 4.3.3.</s:footnote>:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>ES2 attribute types</s:formal-item-title>
          <s:list-unordered>
            <s:list-item><s:term s:type="type">float</s:term></s:list-item>
            <s:list-item><s:term s:type="type">vec2</s:term></s:list-item>
            <s:list-item><s:term s:type="type">vec3</s:term></s:list-item>
            <s:list-item><s:term s:type="type">vec4</s:term></s:list-item>
            <s:list-item><s:term s:type="type">mat2</s:term></s:list-item>
            <s:list-item><s:term s:type="type">mat3</s:term></s:list-item>
            <s:list-item><s:term s:type="type">mat4</s:term></s:list-item>
          </s:list-unordered>
        </s:formal-item>
        <s:paragraph>
          There are likely far more compatibility problems than are
          documented here: Programmers should assume that their GLSL
          programs will not work across different versions of OpenGL.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          Versioning in OpenGL and GLSL is extremely poorly handled.
          Each version of the OpenGL specification mandates one version
          of GLSL and does not require vendors to support older versions.
          The practical result of this is that at the time of writing,
          thirteen (almost identical) shading language programs are required
          to be provided and selected at run-time to match the current
          OpenGL version, if the programmer wants to support all of the
          possible versions of OpenGL. Most proprietary OpenGL drivers
          will support the latest version of the major branch that the
          hardware is capable of supporting, but it differs from vendor
          to vendor whether or not the OpenGL driver will support older
          GLSL versions.
        </s:paragraph>
        <s:paragraph>
          After several abortive attempts to bring order to this mess
          with various APIs, the <s:term s:type="package">jcanephora</s:term>
          package settled on providing a simple interface to the bare
          minimum functionality required to get a program compiled with
          a single fragment and vertex shader. Programmers attempting
          to write portable programs should use a higher level shading
          language to produce a range of GLSL sources, and select the
          correct one at runtime using information retrieved from the
          <s:link s:target="core_interfaces.JCGLMetaType">JCGLMetaType</s:link>
          interface.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLStencilBufferType">
      <s:section-title>JCGLStencilBufferType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLStencilBufferType.html">JCGLStencilBufferType</s:link-external>
          interface provides functions for manipulating the current
          stencil buffer.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To clear the current stencil buffer:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Stencil buffer clear</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLStencilBufferType g;

g.stencilBufferClear(0);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          See the referenced 
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLStencilBufferType.html">JavaDoc</s:link-external>
          for the full range of functions. Most
          of the functions will raise exceptions if the current framebuffer
          configuration does not include a stencil buffer; this is considered
          to be behaviour preferable to silently producing incorrect results.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions, and appear to
          behave identically.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The various OpenGL functions are somewhat weakly typed,
          and follow the usual OpenGL convention of using integer
          constants rather than enumerations. It's not really possible to
          work out how to use them without checking the
          documentation. The functions provided in the
          <s:term s:type="package">JCGLStencilBuffer</s:term> interface
          are somewhat more self-documenting and are much more
          difficult to use incorrectly
          <s:footnote>Although some would argue that it's difficult to use the stencil buffer correctly in the first place!</s:footnote>.
        </s:paragraph>
      </s:subsection>
    </s:section>
    
    <s:section xml:id="core_interfaces.JCGLTextures2DStatic">
      <s:section-title>JCGLTextures2DStatic*</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLTextures2DStaticCommonType.html">JCGLTextures2DStatic</s:link-external>
          interfaces provide functions for allocating, loading,
          and using 2D textures.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          The <s:term s:type="type">JCGLTextures2DStatic*</s:term>
          interfaces expose functions that
          will allocate textures of formats supported by the current
          implementation. The interfaces only expose textures that are
          <s:term s:type="emphasis">required</s:term> to be supported by
          each version of the OpenGL specification. Unfortunately, OpenGL 2.1
          does not require any particular formats, so it was necessary to
          determine which are actually supported in practice and expose
          those. The
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLTextures2DStaticCommonType.html">JCGLTextures2DStaticCommonType</s:link-external>
          interface exposes the functions required to manipulate textures
          and the subinterfaces expose the allocation functions.
        </s:paragraph>
        <s:paragraph>
          To allocate a <s:term s:type="expression">256 * 256</s:term>
          RGBA texture, 8 bits per channel (four bytes per pixel),
          with nearest-neighbour filtering and repeat wrapping around
          both axes:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Texture allocation</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLTextures2DStaticCommonType g;

Texture2DStaticType t =
  g.texture2DStaticAllocateRGBA8888(
    "texture",
    256,
    256,
    TextureWrapS.TEXTURE_WRAP_REPEAT,
    TextureWrapT.TEXTURE_WRAP_REPEAT,
    TextureFilterMinification.TEXTURE_FILTER_NEAREST,
    TextureFilterMagnification.TEXTURE_FILTER_NEAREST);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          A spatial cursor interface is provided to populate allocated
          textures with data (an opaque blue in this example):
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Texture population</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLTextures2DStaticCommonType g;

Texture2DStaticUpdateType td = Texture2DStaticUpdate.newReplacingAll(t);
SpatialCursorWritable4iType c = td.getCursor4i();

for (int y = 0; y < 256; ++y) {
  for (int x = 0; x < 256; ++x) {
    c.seekTo(x, y);
    c.put4i(0, 0, 0xff, 0xff);
  }
}

g.texture2DStaticUpdate(td);
]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The spatial cursor interface uses the same coordinate system
          as OpenGL with regards to pixel data: <s:term s:type="constant">(0, 0)</s:term>
          is considered to be the bottom-left corner of the texture.
        </s:paragraph>
        <s:paragraph>
          In order to use textures in shaders, textures must be bound
          to the OpenGL texture units. The current texture units are
          obtained with the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLTextureUnitsType.html#textureGetUnits()">textureGetUnits()</s:link-external>
          function. The textures can then be bound to the units and
          the units passed to shaders via uniform parameters:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Texture binding</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLTextures2DStaticCommonType gt;
JCGLTextureUnitsType gu;

List<TextureUnitType> units = gu.textureUnitsGet();

gt.texture2DStaticBind(units[0], t);
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          The common subset of textures that are supported by all
          OpenGL implementations is vanishingly small.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The OpenGL texture API is legacy-ridden and insane. The
          sheer number of ways that the API can be used incorrectly
          vastly outnumber the correct usage patterns. In fact, the
          OpenGL ES 2 and OpenGL 3.0 specifications require mutually
          incompatible parameters to be passed! The 
          <s:term s:type="type">JCGLTextures2DStatic</s:term> interfaces
          provide a sane and statically safe way to allocate and use
          textures: The programmer is prevented at compile-time from
          allocating a texture format that will not be supported on the
          current implementation.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLTexturesCubeStatic">
      <s:section-title>JCGLTexturesCubeStatic*</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLTexturesCubeStaticCommonType.html">JCGLTexturesCubeStatic*</s:link-external>
          interfaces provide functions for allocating, loading,
          and using cube map textures.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          Usage of the <s:term s:type="type">JCGLTexturesCubeStatic*</s:term> interfaces
          is mostly identical to the
          <s:link s:target="core_interfaces.JCGLTextures2DStatic">JCGLTextures2DStatic</s:link>
          interfaces, except that the programmer is typically required to
          state the face of the cube to which the current operation applies.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Cube map coordinate systems</s:subsection-title>
        <s:paragraph>
          Note that in the OpenGL specification, cube textures arbitrarily
          use a left-handed coordinate system as opposed to OpenGL's right-handed system.
          This is a frequent source of errors in programs. See the following fragment
          shader:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Cube map shader</s:formal-item-title>
          <s:verbatim><![CDATA[
in vec3 f_normal;   // Eye-space surface normal
in vec3 f_position; // Eye-space surface position

uniform mat4        m_view_inverse; // Inverse view matrix, eye-space -> world-space.
uniform samplerCube t_reflection;

out vec4 frag_color;

void
main (void)
{
  vec3 n = normalize (f_normal);
  vec3 v = normalize (f_position);
  vec3 r = reflect (v, n);
  vec3 u = m_view_inverse * r;

  frag_color = texture (t_reflection, u);
}]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          The program calculates a reflection vector 
          <s:term s:type="variable">r</s:term> from the eye-space incident vector
          <s:term s:type="variable">f_position</s:term> and eye-space surface normal
          <s:term s:type="variable">f_normal</s:term>. It transforms 
          <s:term s:type="variable">r</s:term> back into world-space, giving
          <s:term s:type="variable">u</s:term>, and then uses <s:term s:type="variable">u</s:term>
          to index into the cube texture. This would be textbook-correct, if OpenGL
          didn't arbitrarily use a left-handed coordinate system for cube textures! 
          The coordinates <s:term s:type="variable">u</s:term> are obviously specified 
          in a right-handed coordinate system. The practical results of this are that 
          all of the cube texture faces will be displayed upside down, and the
          familiar concept of the negative Z axis meaning "forwards" will be reversed.
        </s:paragraph>
        <s:paragraph>
           The <s:term s:type="package">jcanephora</s:term> package contains support
           for using right-handed cube maps in OpenGL, consistent with OpenGL's
           right-handed coordinate system. In order to use right-handed cube maps,
           the following steps are required:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Cube map addressing</s:formal-item-title>
          <s:list-ordered>
            <s:list-item>
              Cube map textures are supplied to the OpenGL implementation using
              the "RH" variants of the texture loading and update functions. See
              <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLTexturesCubeStaticCommonType.html#textureCubeStaticUpdateRH(com.io7m.jcanephora.CubeMapFaceRH,%20com.io7m.jcanephora.TextureCubeStaticUpdateType)">textureCubeStaticUpdateRH</s:link-external>,
              and the "RH" variants of functions in the
              <s:link s:target="highlevel.textureloader">TextureLoaderType</s:link>
              interface. Faces are specified in a manner consistent with OpenGL's
              coordinate system. Informally, the "forward" face of the cube map
              is the negative Z face, the "right" face of the cube map is the
              positive X face, and so on.
            </s:list-item>
            <s:list-item>
              In shaders, the coordinates passed to the <s:term s:type="function">texture</s:term>
              function 
              (or <s:term s:type="function">textureCube</s:term> function, on old OpenGL implementations)
              should be multiplied with a matrix that effectively negates the <s:term s:type="variable">Y</s:term>
              and <s:term s:type="variable">Z</s:term> components.
            </s:list-item>
          </s:list-ordered>
        </s:formal-item>
        <s:paragraph>
          The earlier example shader becomes:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Cube map shader</s:formal-item-title>
          <s:verbatim><![CDATA[
in vec3 f_normal;   // Eye-space surface normal
in vec3 f_position; // Eye-space surface position

uniform mat4        m_view_inverse; // Inverse view matrix, eye-space -> world-space.
uniform samplerCube t_reflection;

out vec4 frag_color;

void
main (void)
{
  const mat3 m_t = mat3 (
    1.0,  0.0,  0.0,
    0.0, -1.0,  0.0,
    0.0,  0.0, -1.0
  );

  vec3 n = normalize (f_normal);
  vec3 v = normalize (f_position);
  vec3 r = reflect (v, n);
  vec3 u = m_view_inverse * r;
  vec3 w = m_t * u;

  frag_color = texture (t_reflection, w);
}]]></s:verbatim>
        </s:formal-item>
        <s:paragraph>
          This approach means that both the loading and generation of cube textures
          is consistent with that of 2D textures and the rest of OpenGL, and the 
          complexity of addressing the textures is limited to one function call in 
          shaders. Renderers that produce cube maps do not need to use unusual
          projection matrices to "flip" the coordinate system when rendering, and
          everything works according to the principles of least astonishment!
        </s:paragraph>
        <s:paragraph>
          The correct solution to the problem would have been for the cube map 
          coordinate system  to have been in a consistent right-handed coordinate
          space to begin with.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          See <s:link s:target="core_interfaces.JCGLTextures2DStatic">JCGLTextures2DStatic*</s:link>.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          See <s:link s:target="core_interfaces.JCGLTextures2DStatic">JCGLTextures2DStatic*</s:link>.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.JCGLViewportType">
      <s:section-title>JCGLViewportType</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLViewportType.html">JCGLViewportType</s:link-external>
          interface provides functions for configuring the current
          viewport transformation.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Usage examples</s:subsection-title>
        <s:paragraph>
          To specify a <s:term s:type="expression">320 * 240</s:term>
          viewport, with the origin at <s:term s:type="expression">(32, 64)</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Viewport</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLViewportType g;

g.viewportSet(
  new VectorI2I(32, 64),
  new VectorI2I(640, 480));
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Version support</s:subsection-title>
        <s:paragraph>
          All versions of OpenGL support these functions and appear
          to behave identically.
        </s:paragraph>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Design/Rationale</s:subsection-title>
        <s:paragraph>
          The interface exposed is slightly more compact than the
          existing OpenGL API.
        </s:paragraph>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.ProjectionMatrix">
      <s:section-title>ProjectionMatrix</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/ProjectionMatrix.html">ProjectionMatrix</s:link-external>
          class provides functions for producing projection matrices.
        </s:paragraph>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/ProjectionMatrix.html#makeOrthographicProjection(com.io7m.jtensors.MatrixM4x4F,%20double,%20double,%20double,%20double,%20double,%20double)">makeOrthographicProjection</s:link-external>
          function produces a matrix representing an orthographic projection
          based upon the given clipping plane coordinates.
        </s:paragraph>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/ProjectionMatrix.html#makeFrustumProjection(com.io7m.jtensors.MatrixM4x4F,%20double,%20double,%20double,%20double,%20double,%20double)">makeFrustumProjection</s:link-external>
          function produces a matrix representing a perspective projection
          based upon the given frustum parameters.
        </s:paragraph>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/ProjectionMatrix.html#makePerspectiveProjection(com.io7m.jtensors.MatrixM4x4F,%20double,%20double,%20double,%20double)">makePerspectiveProjection</s:link-external>
          function produces a matrix representing a perspective projection
          based upon the given near and far clipping planes, the given
          horizontal field of view (in radians), and viewport aspect ratio.
          Essentially, a frustum is constructed with the right clipping plane 
          <s:term s:type="expression">x_max</s:term> given by
          <s:term s:type="expression">near_z * tan (horizontal_fov / 2)</s:term>,
          and the top clipping plane <s:term s:type="expression">y_max</s:term> 
          given by <s:term s:type="expression">y_max / aspect</s:term>:
        </s:paragraph>
        <s:formal-item s:kind="images">
          <s:formal-item-title>Perspective projection</s:formal-item-title>
          <s:image s:source="images/projection.png">Perspective projection</s:image>
        </s:formal-item>
      </s:subsection>
    </s:section>

    <s:section xml:id="core_interfaces.ViewMatrix">
      <s:section-title>ViewMatrix</s:section-title>
      <s:section-contents/>
      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/ViewMatrix.html">ViewMatrix</s:link-external>
          class provides functions for producing view matrices.
        </s:paragraph>
        <s:paragraph>
          The class provides <s:term s:type="function">lookAt()</s:term> functions
          that will be familiar to any programmer that has used the
          <s:term s:type="package">GLU</s:term> equivalents.
        </s:paragraph>
      </s:subsection>
    </s:section>
  </s:part>

  <s:part xml:id="highlevel">
    <s:part-title>High-level Interfaces</s:part-title>
    <s:part-contents/>

    <s:section xml:id="highlevel.overview">
      <s:section-title>Overview</s:section-title>
      <s:paragraph>
        The <s:term s:type="package">jcanephora</s:term> package
        also provides a number of optional higher-level APIs built
        upon the <s:link s:target="core_interfaces">core interfaces</s:link>.
      </s:paragraph>
    </s:section>

	  <s:section xml:id="highlevel.textureloader">
	    <s:section-title>TextureLoader API</s:section-title>
	    <s:section-contents/>

      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/TextureLoaderType.html">TextureLoaderType</s:link-external>
          interface defines a set of functions for loading images into
          OpenGL textures from Java input streams. The functions can
          convert arbitrary images into specific formats upon loading,
          or can infer an appropriate texture type based on the loaded
          image format.
        </s:paragraph>
      </s:subsection>
      
      <s:subsection>
        <s:subsection-title>Implementations</s:subsection-title>
        <s:paragraph>
          Currently, an implementation based on Java's
          <s:link-external s:target="http://docs.oracle.com/javase/6/docs/api/javax/imageio/ImageIO.html">ImageIO</s:link-external>
          interface is provided. See the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/texload/imageio/TextureLoaderImageIO.html">TextureLoaderImageIO</s:link-external>
          documentation for details on how to instantiate that implementation.
        </s:paragraph>
      </s:subsection>
	  </s:section>
	  
	  <s:section xml:id="highlevel.batchexec">
	    <s:section-title>Batched Execution API</s:section-title>
	    <s:section-contents/>

      <s:subsection>
        <s:subsection-title>Description</s:subsection-title>
        <s:paragraph>
          The <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBExecutorType.html">JCBExecutorType</s:link-external>
          interface provides an interface with stronger checking
          than the
          <s:link s:target="core_interfaces.JCGLShaders">JCGLShaders</s:link>
          interfaces. Essentially, it performs inexpensive runtime checks
          to ensure that the programmer has not forgotten to assign
          values to the current program's uniform parameters, and also
          that the programmer has not forgotten to bind array buffer
          attributes to the current program's attributes.
        </s:paragraph>
        <s:paragraph>
          The described checks can be invaluable during development,
          as shader interfaces often change (when uniforms and attributes
          are renamed), and in typical OpenGL style, this usually leads
          to silent failure and incorrect results rather than loudly-signalled
          errors. The <s:term s:type="type">JCBExecutorType</s:term> interface
          eliminates those issues.
        </s:paragraph>
      </s:subsection>
      
      <s:subsection>
        <s:subsection-title>Usage</s:subsection-title>
        <s:paragraph>
          Users pass compiled shaders to the functions
          provided by the 
          <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBExecutor.html">JCBExecutor</s:link-external>
          type, which will return values of type
          <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBExecutorType.html">JCBExecutorType</s:link-external>.
          Users then call the 
          <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBExecutorType.html#execRun(com.io7m.jcanephora.batchexec.JCBExecutorProcedureType)">execRun</s:link-external>
          function, passing it a value of type
          <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBExecutorProcedureType.html">JCBExecutorProcedureType</s:link-external>.
          The executor then evaluates the given function, passing it a value of type
          <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBProgramType.html">JCBProgramType</s:link-external>.
          Inside the passed <s:term s:type="function">JCBExecutorProcedureType</s:term>,
          the user configures program attributes and uniforms and then instructs the
          program to execute with the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBProgramType.html#programExecute(com.io7m.jcanephora.batchexec.JCBProgramProcedureType)">programExecute()</s:link-external>
          function (typically executing
          <s:link-external s:target="apidocs/com/io7m/jcanephora/api/JCGLDrawType.html">JCGLDrawType</s:link-external>
          functions in the process).
        </s:paragraph>
        <s:paragraph>
          The purpose of these multiple levels of indirection is to allow
          for efficient batching and checking of shader usage. When an
          execution is started with <s:term s:type="function">execRun</s:term>,
          the executor activates the program that it is supervising and passes
          it to the given procedure. It then deactivates the program and clears
          any modified state when the procedure returns (regardless of whether
          it throws an exception or not). This frees the programmer from having
          to manually handle a stack of state as in traditional OpenGL programming,
          eliminating classes of bugs inherent in that approach.
        </s:paragraph>
        <s:paragraph>
          When the programmer instructs the system to start drawing with
          the given <s:term s:type="type">JCBProgramType</s:term>, the
          executor checks that all required attributes and uniforms have
          been configured. The programmer can also elect to re-use the
          previous values without having to re-send the data to the GPU,
          saving bandwidth. The system will complain loudly if the programmer
          instructs the system to re-use values that have never been
          set.
        </s:paragraph>
        <s:formal-item s:kind="examples">
          <s:formal-item-title>Batched execution</s:formal-item-title>
<s:verbatim><![CDATA[
JCGLInterfaceCommonType g;
ProgramUsableType p;
IndexBufferType indices;
ArrayBufferType a;
LogUsableType log;
List<TextureUnitType> units;

JCBExecutorType e = JCBExecutor.newExecutorWithoutDeclarations(g, p, log);
e.execRun(new JCBExecutorProcedureType<Exception>() {
  @Override call(
    final JCBProgramType program)
    throws JCGLException,
      Exception
  {
    program.programAttributeBind("position", a.arrayGetAttribute("v_position"));
    program.programAttributeBind("normal", a.arrayGetAttribute("v_normal"));
    program.programUniformPutTextureUnit("t_albedo", units.get(0));
    program.programExecute( 
      new JCBProgramProcedureType<Exception>() {
        @Override call() 
          throws JCGLException, 
            Exception
        {
          g.drawElements(Primitives.PRIMITIVE_TRIANGLES, indices);
        }
      }
    );
  }
});
]]></s:verbatim>
        </s:formal-item>
      </s:subsection>
      <s:subsection>
        <s:subsection-title>Declarations</s:subsection-title>
        <s:paragraph>
          GLSL compilers are allowed to remove attributes and uniforms if
          they turn out to be unused after optimization. The problem is that
          the OpenGL API does not provide a way to distinguish between
          attributes and uniforms that were not declared, and attributes
          and uniforms that were optimized out. Because different GLSL compilers
          vary in their ability to perform optimizations, the set of uniforms
          and attributes that must be assigned values differs at run-time
          between implementations!
        </s:paragraph>
        <s:paragraph>
          This obviously causes serious problems for execution
          systems that want to ensure correctness by requiring that all 
          attributes and uniforms must be assigned. If the programmer
          specifies a value for a uniform or attribute 
          <s:term s:type="variable">p</s:term> and the system then checks
          to see if
          <s:term s:type="variable">p</s:term> exists in the given program
          and finds that it doesn't, it is unable to tell if
          <s:term s:type="variable">p</s:term> was not declared in the
          program (which is an error that must be signalled), or if the
          GLSL compiler optimized it out (which is not an error; the program
          must appear to have exactly the same set of parameters on all implementations
          for the sake of programmer sanity).
        </s:paragraph>
        <s:paragraph>
          Clearly, the system needs to be provided with the
          <s:term s:type="emphasis">declared</s:term> program parameters,
          as opposed to only having the list of the
          <s:term s:type="emphasis">resulting post-compilation</s:term> parameters.
        </s:paragraph>
        <s:paragraph>
          At this point, the programmer has two realistic options. Either, the
          programmer reimplements part of the GLSL compiler himself
          <s:footnote>
            Presumably whilst burning the OpenGL committee in efigy.
          </s:footnote>, or use a higher level shading language such
          as Parasol <s:footnote>
            <s:link-external s:target="http://io7m.com/software/parasol">http://io7m.com/software/parasol</s:link-external>
          </s:footnote>, which can provide the required lists of 
          declared parameters at runtime.
        </s:paragraph>
        <s:paragraph>
          Assuming that the programmer has been able to obtain the
          required set of parameters, these can be provided to the
          <s:link-external s:target="apidocs/com/io7m/jcanephora/batchexec/JCBExecutor.html">JCBExecutor</s:link-external>
          constructor functions, allowing the system to provide much
          stronger checking at runtime.
        </s:paragraph>
      </s:subsection>
	  </s:section>
  </s:part>

  <s:part>
    <s:part-title>API Reference</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Javadoc</s:section-title>
      <s:paragraph>
        API documentation for the package is provided via the
        included <s:link-external s:target="apidocs">JavaDoc</s:link-external>.
      </s:paragraph>
    </s:section>
  </s:part>
  
  <s:part>
    <s:part-title>Listings</s:part-title>
    <s:part-contents/>
    <s:section>
      <s:section-title>Listings</s:section-title>
      <s:formal-item s:kind="listings_table">
        <s:formal-item-title>List of examples</s:formal-item-title>
        <s:formal-item-list s:kind="examples"/>
      </s:formal-item>
    </s:section>
  </s:part>

</s:document>
